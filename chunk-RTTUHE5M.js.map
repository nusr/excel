{
  "version": 3,
  "sources": ["../src/util/split.ts", "../src/canvas/util.ts", "../src/canvas/constant.ts", "../src/canvas/offScreenWorker.ts", "../src/canvas/worker.ts"],
  "sourcesContent": ["export function splitToWords(str: string): string[] {\n  if (!str) {\n    return [];\n  }\n  // unicode\n  if (typeof Intl === 'undefined' || typeof Intl.Segmenter !== 'function') {\n    // firefox\n    return [...str];\n  }\n  const list = new Intl.Segmenter([], { granularity: 'word' }).segment(str);\n  const arr = [...list];\n  return arr.map((x) => x.segment);\n}\n", "import { splitToWords } from '@/util/split';\nimport { getThemeColor, sizeConfig } from '@/theme';\nimport { npx, dpr } from '@/util/dpr';\nimport { isEmpty } from '@/util/lodash';\nimport { makeFont } from '@/util/style';\nimport {\n  DEFAULT_FONT_SIZE,\n  ERROR_SET,\n  MERGE_CELL_LINE_BREAK,\n  DEFAULT_FORMAT_CODE,\n  DEFAULT_LINE_WIDTH,\n  BORDER_TYPE_MAP,\n} from '@/util/constant';\nimport {\n  CanvasOverlayPosition,\n  ErrorTypes,\n  Point,\n  EUnderLine,\n  IWindowSize,\n  ResultType,\n  StyleType,\n  EHorizontalAlign,\n  EVerticalAlign,\n  BorderType,\n  BorderItem,\n  ThemeType,\n} from '@/types';\nimport { numberFormat, isDateFormat } from '@/model/numberFormat';\nimport { isMergeContent } from '@/util/util';\n\nconst measureTextMap = new Map<string, IWindowSize>();\n\nexport function measureText(\n  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  char: string,\n): IWindowSize {\n  const mapKey = `${char}__${ctx.font}`;\n  if (measureTextMap.has(mapKey)) {\n    return measureTextMap.get(mapKey)!;\n  }\n  const text = ctx.measureText(char);\n  const { actualBoundingBoxAscent, actualBoundingBoxDescent } = text;\n  const h = actualBoundingBoxAscent + actualBoundingBoxDescent;\n  const w = text.width;\n  const width = Math.ceil(w / dpr());\n  const height = Math.ceil(h / dpr());\n  const result = { width, height };\n  measureTextMap.set(mapKey, result);\n  return result;\n}\n\nexport function fillRect(\n  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n): void {\n  ctx.fillRect(npx(x), npx(y), npx(width), npx(height));\n}\n/* jscpd:ignore-start */\nexport function strokeRect(\n  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n): void {\n  ctx.strokeRect(npx(x), npx(y), npx(width), npx(height));\n}\n\nexport function clearRect(\n  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n): void {\n  ctx.clearRect(npx(x), npx(y), npx(width), npx(height));\n}\n/* jscpd:ignore-end */\n\nexport function fillText(\n  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  text: string,\n  x: number,\n  y: number,\n) {\n  ctx.fillText(text, npx(x), npx(y));\n}\n\nexport function drawLines(\n  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  pointList: Point[],\n): void {\n  if (pointList.length === 0) {\n    return;\n  }\n  ctx.beginPath();\n  for (let i = 0; i < pointList.length; i += 2) {\n    const first = pointList[i];\n    const second = pointList[i + 1];\n    ctx.moveTo(npx(first[0]), npx(first[1]));\n    ctx.lineTo(npx(second[0]), npx(second[1]));\n  }\n  ctx.stroke();\n}\n\nexport function drawTriangle(\n  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  point1: Point,\n  point2: Point,\n  point3: Point,\n) {\n  ctx.beginPath();\n  ctx.moveTo(npx(point1[0]), npx(point1[1]));\n  ctx.lineTo(npx(point2[0]), npx(point2[1]));\n  ctx.lineTo(npx(point3[0]), npx(point3[1]));\n  ctx.fill();\n}\n\nexport function getDoubleLine(\n  pointList: Point[],\n  position: 'top' | 'bottom' | 'left' | 'right',\n  isShort: boolean,\n) {\n  const result = pointList.slice();\n  const [start, end] = pointList;\n  const t = DEFAULT_LINE_WIDTH * 2;\n  const other = isShort ? t : 0;\n  if (position === 'bottom') {\n    result.push([start[0] + other, start[1] - t], [end[0] - other, end[1] - t]);\n  } else if (position === 'top') {\n    result.push([start[0] + other, start[1] + t], [end[0] - other, end[1] + t]);\n  } else if (position === 'left') {\n    result.push([start[0] + t, start[1] + other], [end[0] + t, end[1] - other]);\n  } else if (position === 'right') {\n    result.push([start[0] - t, start[1] + other], [end[0] - t, end[1] - other]);\n  }\n  return result;\n}\n\nfunction splitWords(\n  text: string,\n  isWrapText?: boolean,\n  isMergeContent?: boolean,\n): string[] {\n  if (isMergeContent) {\n    if (isWrapText) {\n      return text.split(MERGE_CELL_LINE_BREAK);\n    } else {\n      return splitToWords(text.replaceAll(MERGE_CELL_LINE_BREAK, ''));\n    }\n  } else {\n    return splitToWords(text);\n  }\n}\n\nexport function drawAntLine(\n  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n) {\n  ctx.setLineDash([npx(8), npx(6)]);\n  const offset = DEFAULT_LINE_WIDTH;\n  strokeRect(\n    ctx,\n    x + offset,\n    y + offset,\n    width - offset * 2,\n    height - offset * 2,\n  );\n  ctx.setLineDash([]);\n}\n\nfunction getLineDash(type?: BorderType) {\n  let dash: number[] = [];\n  if (type === 'hair') {\n    dash = [DEFAULT_LINE_WIDTH, DEFAULT_LINE_WIDTH];\n  } else if (type === 'dotted' || type === 'mediumDashed') {\n    dash = [DEFAULT_LINE_WIDTH * 2, DEFAULT_LINE_WIDTH * 2];\n  } else if (type === 'dashed') {\n    dash = [DEFAULT_LINE_WIDTH * 4, DEFAULT_LINE_WIDTH * 4];\n  } else if (type === 'dashDot' || type === 'mediumDashDot') {\n    dash = [\n      DEFAULT_LINE_WIDTH * 4,\n      DEFAULT_LINE_WIDTH * 4,\n      DEFAULT_LINE_WIDTH * 8,\n      DEFAULT_LINE_WIDTH * 4,\n    ];\n  } else if (type === 'dashDotDot' || type === 'mediumDashDotDot') {\n    dash = [\n      DEFAULT_LINE_WIDTH * 4,\n      DEFAULT_LINE_WIDTH * 4,\n      DEFAULT_LINE_WIDTH * 8,\n      DEFAULT_LINE_WIDTH * 4,\n      DEFAULT_LINE_WIDTH * 4,\n      DEFAULT_LINE_WIDTH * 4,\n    ];\n  }\n  return dash;\n}\n\nexport function renderBorderItem(\n  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  cellInfo: CanvasOverlayPosition,\n  borderItem: BorderItem | undefined,\n  position: 'top' | 'bottom' | 'left' | 'right',\n  theme?: ThemeType,\n) {\n  if (!borderItem) {\n    return;\n  }\n  const { top, left, width, height } = cellInfo;\n\n  let list: Point[] = [];\n  if (position === 'top') {\n    list = [\n      [left, top],\n      [left + width, top],\n    ];\n  } else if (position === 'bottom') {\n    list = [\n      [left, top + height],\n      [left + width, top + height],\n    ];\n  } else if (position === 'left') {\n    list = [\n      [left, top],\n      [left, top + height],\n    ];\n  } else if (position === 'right') {\n    list = [\n      [left + width, top],\n      [left + width, top + height],\n    ];\n  }\n  const { type, color } = borderItem;\n  ctx.lineWidth = BORDER_TYPE_MAP[type];\n  ctx.strokeStyle = color || getThemeColor('black', theme);\n  const lineDash = getLineDash(type);\n  if (type === 'double') {\n    list = getDoubleLine(list, position, true);\n  }\n  if (lineDash.length > 0) {\n    ctx.setLineDash(lineDash.map((v) => npx(v)));\n  }\n  drawLines(ctx, list);\n  if (lineDash.length > 0) {\n    ctx.setLineDash([]);\n  }\n}\n\ntype TextItem = { str: string; width: number; height: number };\nexport function renderCell(\n  ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  cellInfo: CanvasOverlayPosition,\n  value: ResultType,\n  style?: Partial<StyleType>,\n  isMergeCell?: boolean,\n  theme?: ThemeType,\n): IWindowSize {\n  const result: IWindowSize = { height: 0, width: 0 };\n  if (value === '' && isEmpty(style)) {\n    return result;\n  }\n  const format = style?.numberFormat || DEFAULT_FORMAT_CODE;\n  const isRight = format === DEFAULT_FORMAT_CODE && typeof value === 'number';\n  const text = numberFormat(value, format);\n  const fontSize = style?.fontSize ? style.fontSize : DEFAULT_FONT_SIZE;\n  const font = makeFont(\n    style?.isItalic ? 'italic' : 'normal',\n    style?.isBold ? 'bold' : '500',\n    npx(fontSize),\n    style?.fontFamily,\n  );\n\n  // draw background color\n  if (style?.fillColor) {\n    ctx.fillStyle = style?.fillColor;\n    fillRect(ctx, cellInfo.left, cellInfo.top, cellInfo.width, cellInfo.height);\n  }\n  // error text\n  let fillStyle = style?.fontColor || getThemeColor('contentColor', theme);\n  if (ERROR_SET.has(text as ErrorTypes)) {\n    fillStyle = getThemeColor('errorFormulaColor', theme);\n  }\n\n  ctx.font = font;\n  ctx.fillStyle = fillStyle;\n\n  const realStyle = style ? { ...style } : {};\n  let align = realStyle?.horizontalAlign;\n  if (realStyle?.horizontalAlign === undefined && isRight) {\n    align = EHorizontalAlign.RIGHT;\n  }\n  realStyle.horizontalAlign = align;\n\n  // show all date text\n  const isDate = !realStyle?.isWrapText && isDateFormat(format);\n  const texts = isDate\n    ? [text]\n    : splitWords(text, style?.isWrapText, isMergeCell);\n  const textList: TextItem[] = texts.map((item) => {\n    const size = measureText(ctx, item);\n    return {\n      str: item,\n      width: size.width,\n      height: size.height === 0 ? fontSize : size.height,\n    };\n  });\n\n  // fill text\n  const { width, height, resultList } = computeCell(\n    textList,\n    cellInfo,\n    realStyle,\n    isMergeContent(Boolean(isMergeCell), text),\n  );\n  if (width > 0 && height > 0) {\n    const lineGap = Math.ceil((fontSize * (sizeConfig.lineHeight - 1)) / 2);\n    let list: Point[] = [];\n    for (const item of resultList) {\n      fillText(ctx, item.text, item.x, item.y);\n      if (realStyle?.underline) {\n        ctx.strokeStyle = fillStyle;\n        const t = item.y + item.height + lineGap / 2;\n        const point: Point[] = [\n          [item.x, t],\n          [item.x + item.width, t],\n        ];\n        if (realStyle?.underline === EUnderLine.DOUBLE) {\n          list = list.concat(getDoubleLine(point, 'bottom', false));\n        } else {\n          list = list.concat(point);\n        }\n      }\n      if (realStyle?.isStrike) {\n        ctx.strokeStyle = fillStyle;\n        const t = item.y + item.height / 2 + lineGap / 2;\n        list = list.concat([\n          [item.x, t],\n          [item.x + item.width, t],\n        ]);\n      }\n    }\n    // underline strike\n    drawLines(ctx, list);\n  }\n\n  result.height = Math.ceil(height);\n  result.width = Math.ceil(width);\n\n  return result;\n}\nfunction computeCell(\n  texts: TextItem[],\n  cellInfo: CanvasOverlayPosition,\n  style?: Partial<StyleType>,\n  isMergeContent?: boolean,\n) {\n  const fontSize = style?.fontSize ? style.fontSize : DEFAULT_FONT_SIZE;\n  const lineGap = Math.ceil((fontSize * (sizeConfig.lineHeight - 1)) / 2);\n  const verticalAlign = style?.verticalAlign ?? EVerticalAlign.MIDDLE;\n  const { left, top, height } = cellInfo;\n  const width = Math.max(cellInfo.width, ...texts.map((v) => v.width));\n  const textList: Array<{\n    text: string;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  }> = [];\n  let textWidth = 0;\n  let textHeight = 0;\n  if (style?.isWrapText && isMergeContent) {\n    let y = 0;\n    for (let i = 0; i < texts.length; i++) {\n      const item = texts[i];\n      textWidth = Math.max(textWidth, item.width);\n      const temp = item.height + lineGap * 2;\n      textHeight += temp;\n      textList.push({\n        text: item.str,\n        x: 0,\n        y,\n        width: item.width,\n        height: item.height,\n      });\n      y += temp;\n    }\n  } else if (style?.isWrapText) {\n    let y = 0;\n    for (let i = 0; i < texts.length; ) {\n      let temp = width;\n      let line = '';\n      let w = 0;\n      let h = 0;\n      while (i < texts.length) {\n        const item = texts[i];\n        if (temp >= item.width) {\n          w += item.width;\n          h = Math.max(h, item.height);\n          temp -= item.width;\n          line += item.str;\n          i++;\n        } else {\n          break;\n        }\n      }\n      if (line) {\n        textWidth = Math.max(textWidth, w);\n        const t = h + lineGap * 2;\n        textHeight += t;\n        textList.push({\n          text: line,\n          x: 0,\n          y,\n          width: w,\n          height: h,\n        });\n        y += t;\n      }\n    }\n  } else {\n    let line = '';\n    let temp = width;\n    for (let i = 0; i < texts.length; i++) {\n      const item = texts[i];\n      if (temp >= item.width) {\n        textWidth += item.width;\n        textHeight = Math.max(textHeight, item.height);\n        line += item.str;\n        temp -= item.width;\n      } else {\n        break;\n      }\n    }\n    textList.push({\n      text: line,\n      x: 0,\n      y: 0,\n      width: textWidth,\n      height: textHeight,\n    });\n  }\n  textHeight = Math.max(textHeight, fontSize * sizeConfig.lineHeight);\n  textWidth += lineGap;\n  textHeight += lineGap;\n  if (textWidth <= width && textHeight <= height) {\n    let x = left + lineGap;\n    let y = top + (height - textHeight) / 2 + lineGap;\n    if (verticalAlign === EVerticalAlign.TOP) {\n      y = top + lineGap;\n    } else if (verticalAlign === EVerticalAlign.BOTTOM) {\n      y = top + (height - textHeight) + lineGap;\n    }\n    if (style?.horizontalAlign === EHorizontalAlign.CENTER) {\n      x = left + (width - textWidth) / 2;\n    } else if (style?.horizontalAlign === EHorizontalAlign.RIGHT) {\n      x = left + (width - textWidth) - lineGap;\n    }\n    for (const item of textList) {\n      item.x = item.x + x;\n      item.y = item.y + y;\n    }\n  }\n  return {\n    width: textWidth,\n    height: textHeight,\n    resultList: textList,\n  };\n}\n", "import { getThemeColor } from '@/theme';\nimport { ThemeType } from '@/types';\nimport { DEFAULT_LINE_WIDTH, DEFAULT_FONT_SIZE } from '@/util/constant';\nimport { makeFont } from '@/util/style';\nimport { npx } from '@/util/dpr';\n\nexport function getHeaderStyle(\n  theme?: ThemeType,\n): Pick<\n  CanvasRenderingContext2D,\n  | 'textAlign'\n  | 'textBaseline'\n  | 'font'\n  | 'fillStyle'\n  | 'lineWidth'\n  | 'strokeStyle'\n> {\n  return {\n    textAlign: 'center',\n    textBaseline: 'middle',\n    font: makeFont(undefined, '500', npx(DEFAULT_FONT_SIZE)),\n    fillStyle: getThemeColor('black', theme),\n    lineWidth: DEFAULT_LINE_WIDTH,\n    strokeStyle: getThemeColor('borderColor', theme),\n  };\n}\n", "import {\n  RequestRender,\n  Point,\n  IRange,\n  CanvasOverlayPosition,\n  IPosition,\n  IWindowSize,\n  WorkerMainView,\n  ContentParams,\n} from '@/types';\nimport {\n  clearRect,\n  fillRect,\n  strokeRect,\n  fillText,\n  drawLines,\n  drawTriangle,\n  drawAntLine,\n  renderBorderItem,\n  renderCell,\n} from './util';\nimport { getThemeColor } from '@/theme';\nimport {\n  DEFAULT_LINE_WIDTH,\n  CELL_HEIGHT,\n  CELL_WIDTH,\n  HIDE_CELL,\n  BORDER_TYPE_MAP,\n} from '@/util/constant';\nimport { getHeaderStyle } from './constant';\nimport { intToColumnName } from '@/util/convert';\nimport { isSheet, isCol, isRow, containRange } from '@/util/range';\nimport { npx, dpr } from '@/util/dpr';\nimport { getCustomWidthOrHeightKey, coordinateToString } from '@/util/util';\n\nconst lineWidth = Math.max(...Object.values(BORDER_TYPE_MAP));\n\n/**\n * run OffScreenWorker in Web Worker env\n */\nexport default class OffScreenWorker implements WorkerMainView {\n  private canvas: OffscreenCanvas;\n  private ctx: OffscreenCanvasRenderingContext2D;\n  private width: number = 0;\n  private height: number = 0;\n  private isRendering = false;\n  private rowMap: Record<string, number> = {};\n  private colMap: Record<string, number> = {};\n  private eventData: Omit<RequestRender, 'status' | 'changeSet'> = {\n    theme: 'light',\n    sheetData: {},\n    canvasSize: {\n      top: 0,\n      left: 0,\n      width: 0,\n      height: 0,\n    },\n    headerSize: {\n      width: 0,\n      height: 0,\n    },\n    currentSheetInfo: {\n      isHide: false,\n      rowCount: 0,\n      colCount: 0,\n      name: '',\n      sheetId: '',\n      tabColor: '',\n      sort: 1,\n    },\n    scroll: {\n      left: 0,\n      top: 0,\n      row: 0,\n      col: 0,\n      scrollLeft: 0,\n      scrollTop: 0,\n    },\n    range: {\n      row: 0,\n      col: 0,\n      rowCount: 1,\n      colCount: 1,\n      sheetId: '',\n    },\n    copyRange: undefined,\n    customHeight: {},\n    customWidth: {},\n    currentMergeCells: [],\n  };\n  constructor(canvas: OffscreenCanvas) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d')!;\n    const size = dpr();\n    this.ctx.scale(size, size);\n  }\n  render(data: RequestRender) {\n    if (data.changeSet.size === 0) {\n      return;\n    }\n    if (this.isRendering) {\n      return;\n    }\n    this.isRendering = true;\n    this.eventData = data;\n    this.clear();\n    const { ctx } = this;\n    ctx.strokeStyle = getThemeColor('primaryColor', data.theme);\n    ctx.fillStyle = getThemeColor('white', data.theme);\n    ctx.lineWidth = DEFAULT_LINE_WIDTH * 2;\n\n    const { width, height } = this.eventData.canvasSize;\n    const headerSize = this.eventData.headerSize;\n    const { endRow, contentHeight } = this.renderRowsHeader(height);\n    const { endCol, contentWidth } = this.renderColsHeader(width);\n    this.renderGrid(width - headerSize.width, height - headerSize.height);\n    this.renderTriangle();\n\n    this.renderMergeCell();\n\n    this.ctx.fillStyle = getThemeColor('selectionColor', this.eventData.theme);\n    const result = this.renderSelection({\n      endRow,\n      endCol,\n      contentHeight,\n      contentWidth,\n    });\n    this.renderAntLine(result);\n    this.renderContent({ endRow, endCol, contentHeight, contentWidth });\n    this.ctx.lineWidth = lineWidth;\n    strokeRect(this.ctx, result.left, result.top, result.width, result.height);\n    this.isRendering = false;\n    return { rowMap: this.rowMap, colMap: this.colMap };\n  }\n  resize(data: IWindowSize) {\n    this.width = data.width;\n    this.height = data.height;\n    this.canvas.width = npx(data.width);\n    this.canvas.height = npx(data.height);\n  }\n  private clear() {\n    clearRect(this.ctx, 0, 0, this.width, this.height);\n  }\n\n  private renderRowsHeader(height: number) {\n    const { row: rowIndex } = this.eventData.scroll;\n    const headerSize = this.eventData.headerSize;\n    const { rowCount } = this.eventData.currentSheetInfo;\n    this.ctx.save();\n    const range = this.eventData.range;\n    fillRect(this.ctx, 0, headerSize.height, headerSize.width, height);\n    Object.assign(this.ctx, getHeaderStyle(this.eventData.theme));\n    const pointList: Point[] = [];\n    let y = headerSize.height;\n    let i = rowIndex;\n\n    for (; i < rowCount && y < height; i++) {\n      const rowHeight = this.getRowHeight(i);\n      let temp = y;\n      if (i === rowIndex) {\n        temp += DEFAULT_LINE_WIDTH / 2;\n      }\n      pointList.push([0, temp], [headerSize.width, temp]);\n      if (rowHeight > 0) {\n        const check = this.isHighlightRow(range, i);\n        this.ctx.fillStyle = check\n          ? getThemeColor('primaryColor', this.eventData.theme)\n          : getThemeColor('black', this.eventData.theme);\n\n        fillText(\n          this.ctx,\n          String(i + 1),\n          headerSize.width / 2,\n          temp + rowHeight / 2,\n        );\n      }\n      y += rowHeight;\n    }\n    pointList.push([0, y], [headerSize.width, y]);\n    pointList.push([0, 0], [0, y]);\n    drawLines(this.ctx, pointList);\n    this.ctx.restore();\n    const contentHeight = i >= rowCount ? y : height;\n\n    return { endRow: i, contentHeight: Math.floor(contentHeight) };\n  }\n  private renderColsHeader(width: number) {\n    const { col: colIndex } = this.eventData.scroll;\n    const headerSize = this.eventData.headerSize;\n    const { colCount } = this.eventData.currentSheetInfo;\n    const range = this.eventData.range;\n    const pointList: Point[] = [];\n    this.ctx.save();\n    fillRect(this.ctx, headerSize.width, 0, width, headerSize.height);\n    Object.assign(this.ctx, getHeaderStyle());\n\n    let x = headerSize.width;\n    let i = colIndex;\n    for (; i < colCount && x <= width; i++) {\n      const colWidth = this.getColWidth(i);\n      let temp = x;\n      if (i === colIndex) {\n        temp += DEFAULT_LINE_WIDTH / 2;\n      }\n      pointList.push([temp, 0], [temp, headerSize.height]);\n      if (colWidth > 0) {\n        const check = this.isHighlightCol(range, i);\n        this.ctx.fillStyle = check\n          ? getThemeColor('primaryColor', this.eventData.theme)\n          : getThemeColor('black', this.eventData.theme);\n        fillText(\n          this.ctx,\n          intToColumnName(i),\n          temp + colWidth / 2,\n          headerSize.height / 2,\n        );\n      }\n      x += colWidth;\n    }\n    pointList.push([x, 0], [x, headerSize.height]);\n    pointList.push([0, 0], [x, 0]);\n    drawLines(this.ctx, pointList);\n    this.ctx.restore();\n    const contentWidth = i >= colCount ? x : width;\n    return {\n      endCol: i,\n      contentWidth: Math.floor(contentWidth),\n    };\n  }\n  private renderGrid(width: number, height: number): void {\n    const headerSize = this.eventData.headerSize;\n    const { row: rowIndex, col: colIndex } = this.eventData.scroll;\n    const { rowCount, colCount } = this.eventData.currentSheetInfo;\n    this.ctx.save();\n    this.ctx.lineWidth = DEFAULT_LINE_WIDTH;\n    this.ctx.strokeStyle = getThemeColor('borderColor', this.eventData.theme);\n    this.ctx.translate(npx(headerSize.width), npx(headerSize.height));\n    const pointList: Point[] = [];\n    let y = 0;\n    let x = 0;\n    for (let i = rowIndex; i < rowCount && y <= height; i++) {\n      while (i < rowCount && this.getRowHeight(i) === 0) {\n        i++;\n      }\n      pointList.push([0, y], [width, y]);\n      const h = this.getRowHeight(i);\n      y += h;\n    }\n    for (let i = colIndex; i < colCount && x <= width; i++) {\n      while (i < colCount && this.getColWidth(i) === 0) {\n        i++;\n      }\n      pointList.push([x, 0], [x, y]);\n      const w = this.getColWidth(i);\n      x += w;\n    }\n    pointList.push([0, y], [x, y]);\n    pointList.push([x, 0], [x, y]);\n    drawLines(this.ctx, pointList);\n    this.ctx.restore();\n  }\n  private renderTriangle(): void {\n    const headerSize = this.eventData.headerSize;\n    this.ctx.save();\n\n    fillRect(this.ctx, 0, 0, headerSize.width, headerSize.height);\n    this.ctx.fillStyle = getThemeColor(\n      'triangleFillColor',\n      this.eventData.theme,\n    );\n\n    const offset = 2;\n    const minY = Math.floor(offset);\n    const maxY = Math.floor(headerSize.height - offset);\n    const minX = Math.floor(headerSize.width * 0.4);\n    const maxX = Math.floor(headerSize.width - offset);\n\n    drawTriangle(this.ctx, [maxX, minY], [minX, maxY], [maxX, maxY]);\n\n    this.ctx.restore();\n  }\n  private getRowHeight(row: number) {\n    const key = getCustomWidthOrHeightKey(\n      this.eventData.currentSheetInfo.sheetId,\n      row,\n    );\n    const data = this.eventData.customHeight[key];\n    if (!data) {\n      return CELL_HEIGHT;\n    }\n    return data.isHide ? HIDE_CELL : data.len;\n  }\n  private getColWidth(col: number) {\n    const key = getCustomWidthOrHeightKey(\n      this.eventData.currentSheetInfo.sheetId,\n      col,\n    );\n    const data = this.eventData.customWidth[key];\n    if (!data) {\n      return CELL_WIDTH;\n    }\n    return data.isHide ? HIDE_CELL : data.len;\n  }\n  private isHighlightRow(range: IRange, row: number): boolean {\n    if (isSheet(range)) {\n      return true;\n    }\n    if (isCol(range)) {\n      return true;\n    }\n    if (row >= range.row && row < range.row + range.rowCount) {\n      return true;\n    }\n    return false;\n  }\n\n  private isHighlightCol(range: IRange, col: number): boolean {\n    if (isSheet(range)) {\n      return true;\n    }\n\n    if (isRow(range)) {\n      return true;\n    }\n    if (col >= range.col && col < range.col + range.colCount) {\n      return true;\n    }\n    return false;\n  }\n\n  private renderAntLine(position: CanvasOverlayPosition) {\n    const range = this.eventData.copyRange;\n    if (!range || range.sheetId !== this.eventData.currentSheetInfo.sheetId) {\n      return;\n    }\n    this.ctx.lineWidth = lineWidth;\n    this.ctx.strokeStyle = getThemeColor('primaryColor', this.eventData.theme);\n    drawAntLine(\n      this.ctx,\n      position.left,\n      position.top,\n      position.width,\n      position.height,\n    );\n  }\n  private renderMergeCell() {\n    const mergeCells = this.eventData.currentMergeCells;\n    if (mergeCells.length === 0) {\n      return;\n    }\n    const activeCell = this.eventData.range;\n    for (const range of mergeCells) {\n      if (activeCell.row === range.row && activeCell.col === range.col) {\n        continue;\n      }\n      this.clearRect(range);\n    }\n  }\n  /* jscpd:ignore-start */\n  private getCellSize(range: IRange): IWindowSize {\n    let { row, col, colCount, rowCount } = range;\n    let r = row;\n    let c = col;\n    let endRow = row + rowCount;\n    let endCol = col + colCount;\n    const sheetInfo = this.eventData.currentSheetInfo;\n    if (isSheet(range)) {\n      c = 0;\n      endCol = sheetInfo.colCount;\n      r = 0;\n      endRow = sheetInfo.rowCount;\n    } else if (isCol(range)) {\n      r = 0;\n      endRow = sheetInfo.rowCount;\n    } else if (isRow(range)) {\n      c = 0;\n      endCol = sheetInfo.colCount;\n    }\n    let width = 0;\n    let height = 0;\n    for (; r < endRow; r++) {\n      height += this.getRowHeight(r);\n    }\n    for (; c < endCol; c++) {\n      width += this.getColWidth(c);\n    }\n    return { width, height };\n  }\n  private computeCellPosition(range: IRange): IPosition {\n    const { row, col } = range;\n    const size = this.eventData.headerSize;\n    const scroll = this.eventData.scroll;\n\n    let resultX = size.width;\n    let resultY = size.height;\n    let r = scroll.row;\n    let c = scroll.col;\n    if (col >= scroll.col) {\n      while (c < col) {\n        resultX += this.getColWidth(c);\n        c++;\n      }\n    } else {\n      resultX = -size.width;\n      while (c > col) {\n        resultX -= this.getColWidth(c);\n        c--;\n      }\n    }\n    if (row >= scroll.row) {\n      while (r < row) {\n        resultY += this.getRowHeight(r);\n        r++;\n      }\n    } else {\n      resultY = -size.height;\n      while (r > row) {\n        resultY -= this.getRowHeight(r);\n        r--;\n      }\n    }\n    return {\n      top: resultY,\n      left: resultX,\n    };\n  }\n  private getActiveRange(r?: IRange) {\n    const range = r || this.eventData.range;\n    const mergeCells = this.eventData.currentMergeCells;\n    for (const item of mergeCells) {\n      if (containRange(range, item)) {\n        const newRange = {\n          ...item,\n          sheetId: item.sheetId,\n        };\n        return {\n          range: newRange,\n          isMerged: true,\n        };\n      }\n    }\n    return {\n      range,\n      isMerged: false,\n    };\n  }\n  /* jscpd:ignore-end */\n  private clearRect(range: IRange) {\n    const cellSize = this.getCellSize(range);\n    if (cellSize.width <= 0 || cellSize.height <= 0) {\n      return;\n    }\n    const activeCell = this.computeCellPosition(range);\n    const lineWidth = DEFAULT_LINE_WIDTH;\n    clearRect(\n      this.ctx,\n      activeCell.left + lineWidth,\n      activeCell.top + lineWidth,\n      cellSize.width - lineWidth * 2,\n      cellSize.height - lineWidth * 2,\n    );\n  }\n  private renderContent(params: ContentParams) {\n    const { endCol, endRow, contentHeight, contentWidth } = params;\n    const { ctx } = this;\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'top';\n    ctx.lineWidth = DEFAULT_LINE_WIDTH * 2;\n    const headerSize = this.eventData.headerSize;\n    const { row, col } = this.eventData.scroll;\n\n    const maxWidth = Math.floor(contentWidth - headerSize.width);\n    const maxHeight = Math.floor(contentHeight - headerSize.height);\n    ctx.save();\n\n    this.rowMap = {};\n    this.colMap = {};\n\n    const mergeCells = this.eventData.currentMergeCells;\n    for (let rowIndex = row; rowIndex < endRow; rowIndex++) {\n      for (let colIndex = col; colIndex < endCol; colIndex++) {\n        const mergeCell = mergeCells.find(\n          (v) => v.row === rowIndex && v.col === colIndex,\n        );\n\n        this.renderCell(rowIndex, colIndex, mergeCell, maxWidth, maxHeight);\n      }\n    }\n    ctx.restore();\n  }\n  private renderCell(\n    row: number,\n    col: number,\n    mergeCell: IRange | undefined,\n    maxWidth: number,\n    maxHeight: number,\n  ) {\n    const { ctx } = this;\n    const range: IRange = {\n      row: row,\n      col: col,\n      rowCount: 1,\n      colCount: 1,\n      sheetId: '',\n    };\n    const key = coordinateToString(row, col)\n    const cellInfo = this.eventData.sheetData[key];\n    if (!cellInfo) {\n      return;\n    }\n    const cellSize = this.getCellSize(mergeCell || range);\n    if (cellSize.width <= 0 || cellSize.height <= 0) {\n      return;\n    }\n    const position = this.computeCellPosition(range);\n    ctx.lineWidth = DEFAULT_LINE_WIDTH * 2;\n    const theme = this.eventData.theme;\n    const size = renderCell(\n      ctx,\n      {\n        top: position.top,\n        left: position.left,\n        width: Math.min(cellSize.width, maxWidth),\n        height: Math.min(cellSize.height, maxHeight),\n      },\n      cellInfo.value,\n      cellInfo.style,\n      Boolean(mergeCell),\n      theme,\n    );\n    const height = Math.max(this.rowMap[row] ?? 0, size.height);\n    const width = Math.max(this.colMap[col] ?? 0, size.width);\n    if (height >= CELL_HEIGHT) {\n      this.rowMap[row] = height;\n    }\n    if (width >= CELL_WIDTH) {\n      this.colMap[col] = width;\n    }\n    const cellPosition = {\n      top: position.top,\n      left: position.left,\n      height: Math.max(height, cellSize.height),\n      width: Math.max(width, cellSize.width),\n    };\n\n    renderBorderItem(\n      ctx,\n      cellPosition,\n      cellInfo.style?.borderTop,\n      'top',\n      theme,\n    );\n    renderBorderItem(\n      ctx,\n      cellPosition,\n      cellInfo.style?.borderBottom,\n      'bottom',\n      theme,\n    );\n    renderBorderItem(\n      ctx,\n      cellPosition,\n      cellInfo.style?.borderLeft,\n      'left',\n      theme,\n    );\n    renderBorderItem(\n      ctx,\n      cellPosition,\n      cellInfo.style?.borderRight,\n      'right',\n      theme,\n    );\n  }\n  private renderSelection(params: ContentParams): CanvasOverlayPosition {\n    const range = this.eventData.range;\n    if (isSheet(range)) {\n      const result = this.renderSelectAll(params);\n      return result;\n    }\n    if (isCol(range)) {\n      const result = this.renderSelectCol(params);\n      return result;\n    }\n    if (isRow(range)) {\n      const result = this.renderSelectRow(params);\n      return result;\n    }\n    return this.renderSelectRange();\n  }\n\n  private renderSelectRange() {\n    const headerSize = this.eventData.headerSize;\n    const range = this.eventData.range;\n\n    const activeCell = this.computeCellPosition({\n      row: range.row,\n      col: range.col,\n      rowCount: 1,\n      colCount: 1,\n      sheetId: '',\n    });\n    const endCellRow = range.row + range.rowCount - 1;\n    const endCellCol = range.col + range.colCount - 1;\n\n    const temp = {\n      row: endCellRow,\n      col: endCellCol,\n      rowCount: 1,\n      colCount: 1,\n      sheetId: '',\n    };\n    const endCell = this.computeCellPosition(temp);\n    const endCellSize = this.getCellSize(temp);\n    const width = endCell.left + endCellSize.width - activeCell.left;\n    const height = endCell.top + endCellSize.height - activeCell.top;\n\n    // col header\n    fillRect(this.ctx, activeCell.left, 0, width, headerSize.height);\n    // row header\n    fillRect(this.ctx, 0, activeCell.top, headerSize.width, height);\n    const check = range.rowCount > 1 || range.colCount > 1;\n    if (check) {\n      // main\n      fillRect(this.ctx, activeCell.left, activeCell.top, width, height);\n    }\n\n    const list: Point[] = [\n      [activeCell.left, headerSize.height],\n      [activeCell.left + width, headerSize.height],\n    ];\n    list.push(\n      [headerSize.width, activeCell.top],\n      [headerSize.width, activeCell.top + height],\n    );\n    drawLines(this.ctx, list);\n    if (check) {\n      this.renderActiveCell();\n    }\n    return {\n      left: activeCell.left,\n      top: activeCell.top,\n      width,\n      height,\n    };\n  }\n  private renderSelectAll(params: ContentParams): CanvasOverlayPosition {\n    const { contentHeight, contentWidth } = params;\n    const headerSize = this.eventData.headerSize;\n    // main\n    fillRect(this.ctx, 0, 0, contentWidth, contentHeight);\n    this.renderActiveCell();\n    const width = contentWidth - headerSize.width;\n    const height = contentHeight - headerSize.height;\n    return {\n      left: headerSize.width,\n      top: headerSize.height,\n      width,\n      height,\n    };\n  }\n  private renderSelectCol({ contentHeight }: ContentParams) {\n    const headerSize = this.eventData.headerSize;\n    const range = this.eventData.range;\n    const activeCell = this.computeCellPosition(range);\n\n    let strokeWidth = 0;\n    for (\n      let i = range.col, endCol = range.col + range.colCount;\n      i < endCol;\n      i++\n    ) {\n      strokeWidth += this.getColWidth(i);\n    }\n    const realHeight = contentHeight - headerSize.height;\n\n    // col header\n    fillRect(this.ctx, activeCell.left, 0, strokeWidth, contentHeight);\n\n    // row header\n    fillRect(this.ctx, 0, activeCell.top, headerSize.width, realHeight);\n\n    const list: Point[] = [\n      [headerSize.width, headerSize.height],\n      [headerSize.width, contentHeight],\n    ];\n    // row header highlight line\n    drawLines(this.ctx, list);\n    this.renderActiveCell();\n    return {\n      left: activeCell.left,\n      top: headerSize.height,\n      width: strokeWidth,\n      height: realHeight,\n    };\n  }\n  private renderSelectRow({ contentWidth }: ContentParams) {\n    const headerSize = this.eventData.headerSize;\n    const range = this.eventData.range;\n    const activeCell = this.computeCellPosition(range);\n    let strokeHeight = 0;\n    for (\n      let i = range.row, endRow = range.row + range.rowCount;\n      i < endRow;\n      i++\n    ) {\n      strokeHeight += this.getRowHeight(i);\n    }\n    const realWidth = contentWidth - headerSize.width - DEFAULT_LINE_WIDTH;\n    // col header\n    fillRect(this.ctx, activeCell.left, 0, realWidth, headerSize.height);\n\n    // row header\n    fillRect(this.ctx, 0, activeCell.top, contentWidth, strokeHeight);\n\n    const list: Point[] = [\n      [activeCell.left, headerSize.height],\n      [contentWidth, headerSize.height],\n    ];\n    // col header highlight line\n    drawLines(this.ctx, list);\n    this.renderActiveCell();\n    return {\n      left: headerSize.width,\n      top: activeCell.top,\n      width: realWidth,\n      height: strokeHeight,\n    };\n  }\n\n  private renderActiveCell() {\n    const range = this.eventData.range;\n    const temp = this.getActiveRange({\n      row: range.row,\n      col: range.col,\n      rowCount: 1,\n      colCount: 1,\n      sheetId: range.sheetId,\n    }).range;\n    this.clearRect(temp);\n  }\n}\n", "import {\n  RequestInit,\n  IWindowSize,\n  RequestRender,\n  ResponseRender,\n  WorkerMethod\n} from '@/types';\nimport { computeFormulas } from '@/formula';\nimport OffScreenWorker from './offScreenWorker';\nimport { setDpr } from '@/util/dpr';\n\nlet offScreen: OffScreenWorker | null = null;\n\nconst workerMethod: WorkerMethod = {\n  init(data: RequestInit) {\n    offScreen = new OffScreenWorker(data.canvas);\n    setDpr(data.dpr);\n  },\n  resize(data: IWindowSize) {\n    offScreen?.resize(data);\n  },\n  async render(data: RequestRender, cb: (data: ResponseRender) => void) {\n    const result = offScreen?.render(data);\n    if (!result) {\n      return\n    }\n    await cb(result);\n  },\n  computeFormulas,\n}\n\n\nexport default workerMethod\n\n"],
  "mappings": "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",
  "names": ["splitToWords", "str", "x", "measureTextMap", "measureText", "ctx", "char", "mapKey", "text", "actualBoundingBoxAscent", "actualBoundingBoxDescent", "h", "w", "width", "dpr", "height", "result", "fillRect", "x", "y", "npx", "strokeRect", "clearRect", "fillText", "drawLines", "pointList", "i", "first", "second", "drawTriangle", "point1", "point2", "point3", "getDoubleLine", "position", "isShort", "start", "end", "t", "DEFAULT_LINE_WIDTH", "other", "splitWords", "isWrapText", "isMergeContent", "MERGE_CELL_LINE_BREAK", "splitToWords", "drawAntLine", "offset", "getLineDash", "type", "dash", "renderBorderItem", "cellInfo", "borderItem", "theme", "top", "left", "list", "color", "BORDER_TYPE_MAP", "getThemeColor", "lineDash", "v", "renderCell", "value", "style", "isMergeCell", "isEmpty", "format", "DEFAULT_FORMAT_CODE", "isRight", "numberFormat", "fontSize", "DEFAULT_FONT_SIZE", "font", "makeFont", "fillStyle", "ERROR_SET", "realStyle", "align", "textList", "isDateFormat", "item", "size", "resultList", "computeCell", "lineGap", "sizeConfig", "point", "texts", "verticalAlign", "textWidth", "textHeight", "temp", "line", "getHeaderStyle", "theme", "makeFont", "npx", "DEFAULT_FONT_SIZE", "getThemeColor", "DEFAULT_LINE_WIDTH", "lineWidth", "BORDER_TYPE_MAP", "OffScreenWorker", "canvas", "size", "dpr", "data", "ctx", "getThemeColor", "DEFAULT_LINE_WIDTH", "width", "height", "headerSize", "endRow", "contentHeight", "endCol", "contentWidth", "result", "strokeRect", "npx", "clearRect", "rowIndex", "rowCount", "range", "fillRect", "getHeaderStyle", "pointList", "y", "i", "rowHeight", "temp", "check", "fillText", "drawLines", "colIndex", "colCount", "x", "colWidth", "intToColumnName", "h", "w", "offset", "minY", "maxY", "minX", "maxX", "drawTriangle", "row", "key", "getCustomWidthOrHeightKey", "HIDE_CELL", "CELL_HEIGHT", "col", "CELL_WIDTH", "isSheet", "isCol", "isRow", "position", "drawAntLine", "mergeCells", "activeCell", "r", "c", "sheetInfo", "scroll", "resultX", "resultY", "item", "containRange", "cellSize", "params", "maxWidth", "maxHeight", "mergeCell", "v", "coordinateToString", "cellInfo", "theme", "renderCell", "cellPosition", "renderBorderItem", "endCellRow", "endCellCol", "endCell", "endCellSize", "list", "strokeWidth", "realHeight", "strokeHeight", "realWidth", "offScreen", "workerMethod", "data", "OffScreenWorker", "setDpr", "cb", "result", "computeFormulas", "worker_default"]
}
