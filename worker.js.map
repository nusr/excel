{
  "version": 3,
  "sources": ["../src/util/constant.ts", "../src/util/util.ts", "../src/formula/formula/error.ts", "../src/formula/formula/text.ts", "../src/formula/formula/math.ts", "../src/formula/formula/float.ts", "../src/formula/formula/index.ts", "../src/formula/token.ts", "../src/util/convert.ts", "../src/util/range.ts", "../src/util/reference.ts", "../src/formula/scanner.ts", "../src/formula/expression.ts", "../src/formula/parser.ts", "../src/formula/interpreter.ts", "../src/formula/eval.ts", "../src/worker.ts"],
  "sourcesContent": ["import { ErrorTypes, BorderType } from '@/types';\n\nexport const DEFAULT_FONT_SIZE = 12;\nexport const MUST_FONT_FAMILY = 'sans-serif';\nexport const SHEET_NAME_PREFIX = 'Sheet';\nexport const CELL_HEIGHT = 22;\nexport const CELL_WIDTH = 76;\nexport const ROW_TITLE_HEIGHT = CELL_HEIGHT;\nexport const COL_TITLE_WIDTH = CELL_WIDTH / 2;\nexport const HIDE_CELL = 0;\nexport const TEXTAREA_MAX_ROWS = 10;\nexport const MERGE_CELL_LINE_BREAK = '&#10;';\nexport const LINE_BREAK = '\\n';\nexport const CSV_SPLITTER = ',';\nexport const XLSX_MAX_COL_COUNT = 16384; // XFD\nexport const XLSX_MAX_ROW_COUNT = 1048576;\nexport const DEFAULT_ROW_COUNT = 200;\nexport const MAX_ADD_ROW_THRESHOLD = 200;\nexport const DEFAULT_COL_COUNT = 30;\nexport const DEFAULT_POSITION = -999;\n\nexport const SHEET_ITEM_TEST_ID_PREFIX = '__sheet_item_';\nexport const FORMULA_PREFIX = '=';\nexport const SPLITTER = '_';\nexport const MAX_NAME_LENGTH = 35;\nexport const MAX_PARAMS_COUNT = 256;\nexport const DEFINED_NAME_REG_EXP = /^[a-zA-Z_][a-zA-Z0-9_.]*$/;\nexport const FORMULA_MAX_PRECISION = 9;\nexport const FORMULA_EDITOR_ROLE = '__FORMULA_EDITOR_ROLE__';\n\nexport const ERROR_SET = new Set<ErrorTypes>([\n  '#ERROR!',\n  '#DIV/0!',\n  '#NULL!',\n  '#NUM!',\n  '#REF!',\n  '#VALUE!',\n  '#N/A',\n  '#NAME?',\n]);\n\nexport const DEFAULT_LINE_WIDTH = 1;\n\nexport const BORDER_TYPE_MAP: Record<BorderType, number> = {\n  thin: DEFAULT_LINE_WIDTH,\n  hair: DEFAULT_LINE_WIDTH,\n  dotted: DEFAULT_LINE_WIDTH,\n  dashed: DEFAULT_LINE_WIDTH,\n  dashDot: DEFAULT_LINE_WIDTH,\n  dashDotDot: DEFAULT_LINE_WIDTH,\n  double: DEFAULT_LINE_WIDTH,\n  medium: DEFAULT_LINE_WIDTH * 2,\n  mediumDashed: DEFAULT_LINE_WIDTH * 2,\n  mediumDashDot: DEFAULT_LINE_WIDTH * 2,\n  mediumDashDotDot: DEFAULT_LINE_WIDTH * 2,\n  thick: DEFAULT_LINE_WIDTH * 4,\n};\n\nexport const COLOR_PICKER_COLOR_LIST = [\n  '#35322B',\n  '#505050',\n  '#606060',\n  '#6F6F6F',\n  '#8B8B8B',\n  '#B2B2B2',\n  '#CCCCCC',\n  '#E5E5E5',\n  '#F5F5F5',\n  '#FFFFFF',\n  '#9D0000',\n  '#B20000',\n  '#CD0F0F',\n  '#E30909',\n  '#F30B0B',\n  '#FE4B4B',\n  '#FA7979',\n  '#FB9D9D',\n  '#FDCECE',\n  '#FEE7E7',\n  '#B24000',\n  '#CC4F10',\n  '#DF5D00',\n  '#F96800',\n  '#FB8937',\n  '#FF8C51',\n  '#FCA669',\n  '#FDC49B',\n  '#FEE1CD',\n  '#FEF0E6',\n  '#B19401',\n  '#C5A300',\n  '#D8B300',\n  '#EBC301',\n  '#F9D700',\n  '#FBE137',\n  '#FCE869',\n  '#FDF09B',\n  '#FEF7CD',\n  '#FEFBE6',\n  '#58770A',\n  '#688C0D',\n  '#7AA017',\n  '#8BBB11',\n  '#A4DC16',\n  '#BEEE44',\n  '#CEF273',\n  '#DEF6A2',\n  '#EFFBD0',\n  '#F7FDE8',\n  '#007676',\n  '#008A8A',\n  '#009E9E',\n  '#00BBBB',\n  '#1CD8D8',\n  '#2AEAEA',\n  '#76EFEF',\n  '#A3F5F5',\n  '#D1FAFA',\n  '#E8FCFC',\n  '#001F9C',\n  '#0025B7',\n  '#012BD2',\n  '#133DE3',\n  '#2F55EB',\n  '#4567ED',\n  '#738DF2',\n  '#A2B3F6',\n  '#D0D9FB',\n  '#E8ECFD',\n  '#3F0198',\n  '#510EB0',\n  '#6721CB',\n  '#7735D4',\n  '#894EDE',\n  '#9E6DE3',\n  '#AA82E3',\n  '#C7ABED',\n  '#E3D5F6',\n  '#F1EAFA',\n  '#8F0550',\n  '#A1095C',\n  '#C1026B',\n  '#D4157E',\n  '#E7258F',\n  '#F248A6',\n  '#F273B9',\n  '#F6A2D0',\n  '#FBD0E8',\n  '#FDE8F3',\n];\n", "import { SHEET_NAME_PREFIX, SPLITTER } from './constant';\nimport type {\n  WorksheetType,\n  ChangeEventType,\n  Coordinate,\n  ICommandItem,\n  ResultType,\n} from '@/types';\n\nexport function parseNumber(value: any): [boolean, number] {\n  if (typeof value === 'boolean') {\n    return [true, Number(value)];\n  }\n  if (typeof value === 'number' && !isNaN(value)) {\n    return [true, value];\n  }\n  if (typeof value !== 'string') {\n    return [false, 0];\n  }\n  if (value.length > 12) {\n    return [false, 0];\n  }\n  const temp = Number(value);\n  if (isNaN(temp)) {\n    return [false, 0];\n  }\n  return [true, temp];\n}\n\nexport function getListMaxNum(list: string[] = []): number {\n  const idList: number[] = list\n    .map((item) => {\n      return parseNumber(item)[1];\n    })\n    .filter((v) => !isNaN(v));\n  return Math.max(Math.max(...idList), 0);\n}\n\nexport function getDefaultSheetInfo(\n  list: WorksheetType[] = [],\n): Pick<WorksheetType, 'name' | 'sheetId' | 'sort'> {\n  const sheetId =\n    Math.ceil(getListMaxNum(list.map((item) => item.sheetId))) + 1;\n  return {\n    name: `${SHEET_NAME_PREFIX}${sheetId}`,\n    sheetId: String(sheetId),\n    sort: sheetId,\n  };\n}\n\nexport function splitToWords(str: string): string[] {\n  if (!str) {\n    return [];\n  }\n  // unicode\n  if (typeof Intl === 'undefined' || typeof Intl.Segmenter !== 'function') {\n    // firefox\n    return [...str];\n  }\n  const list = new Intl.Segmenter([], { granularity: 'word' }).segment(str);\n  const arr = [...list];\n  return arr.map((x) => x.segment);\n}\nexport function convertStringToResultType(value: any): ResultType {\n  if (typeof value === 'string') {\n    const temp = value.toUpperCase();\n    if (['TRUE', 'FALSE'].includes(temp)) {\n      return temp === 'TRUE';\n    }\n  }\n  if (typeof value === 'boolean') {\n    return value;\n  }\n  if (value === '') {\n    return '';\n  }\n  const [check, num] = parseNumber(value);\n  if (check) {\n    return num;\n  }\n  return value;\n}\n\nexport function coordinateToString(\n  row: number,\n  col: number,\n): `${number}_${number}` {\n  return `${row}${SPLITTER}${col}`;\n}\n\nexport function stringToCoordinate(key: string): Coordinate {\n  const [row, col] = key.split(SPLITTER);\n  const r = parseInt(row, 10);\n  const c = parseInt(col, 10);\n  return {\n    row: isNaN(r) ? -1 : r,\n    col: isNaN(c) ? -1 : c,\n  };\n}\n\nexport function getCustomWidthOrHeightKey(\n  sheetId: string,\n  rowOrCol: number,\n): `${string}_${number}` {\n  return `${sheetId}${SPLITTER}${rowOrCol}`;\n}\n\nexport function widthOrHeightKeyToData(key: string) {\n  const [sheetId, num] = key.split(SPLITTER);\n  const r = parseInt(num, 10);\n  return {\n    sheetId,\n    rowOrCol: isNaN(r) ? -1 : r,\n  };\n}\n\nexport function generateUUID() {\n  let d = new Date().getTime();\n\n  const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(\n    /[xy]/g,\n    function (c) {\n      const r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);\n    },\n  );\n\n  return uuid;\n}\n\nexport function isMobile() {\n  const matchList = [\n    /Android/i,\n    /webOS/i,\n    /iPhone/i,\n    /iPad/i,\n    /iPod/i,\n    /BlackBerry/i,\n    /Windows Phone/i,\n  ];\n  const ua = navigator.userAgent;\n  return matchList.some((v) => ua.match(v));\n}\n\nexport function modelToChangeSet(list: ICommandItem[]) {\n  const result = new Set<ChangeEventType>();\n  for (const item of list) {\n    const type = item.type;\n    result.add(type);\n    if (type === 'worksheets') {\n      if (item.key.includes('style')) {\n        result.add('cellStyle');\n      } else if (item.key.includes('value') || item.key.includes('formula')) {\n        result.add('cellValue');\n      } else {\n        result.add('cellValue');\n        result.add('cellStyle');\n      }\n    } else if (type === 'workbook') {\n      if (item.key.includes('rowCount')) {\n        result.add('row');\n      }\n      if (item.key.includes('colCount')) {\n        result.add('col');\n      }\n    } else if (type === 'customHeight') {\n      result.add('row');\n    } else if (type === 'customWidth') {\n      result.add('col');\n    }\n  }\n  return result;\n}\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function isTestEnv(): boolean {\n  return process.env.NODE_ENV === 'test';\n}\n", "import type { ErrorTypes } from '@/types';\nimport { parseNumber } from '@/util/util';\n\nexport class CustomError extends Error {\n  readonly value: ErrorTypes;\n  constructor(value: ErrorTypes) {\n    super(value);\n    this.value = value;\n  }\n}\n\nexport function assert(\n  condition: boolean,\n  message: ErrorTypes = '#VALUE!',\n): asserts condition {\n  if (!condition) {\n    throw new CustomError(message);\n  }\n}\n\nexport function mustOne(list: any[]): any {\n  assert(list.length === 1);\n  const [value] = list;\n  return value;\n}\n\nexport function mustOneString(list: any[]): string {\n  const value = mustOne(list);\n  assert(typeof value === 'string');\n  return value;\n}\n\nexport function mustOneNumber(list: any[]): number {\n  const value = mustOne(list);\n  const [check, num] = parseNumber(value);\n  assert(check);\n  return num;\n}\n\nexport function mustEmpty(list: any[]) {\n  assert(list.length === 0);\n}\n\nexport function isRelativeReference(value: string) {\n  const realValue = value.toUpperCase();\n  return /^[A-Z]+\\d+$/.test(realValue) || /^[A-Z]+$/.test(realValue);\n}\n\n", "import type { TextFormulaType, ResultType } from '@/types';\nimport { MAX_PARAMS_COUNT } from '@/util/constant';\nimport { assert, mustOneString, mustOneNumber, mustOne } from './error';\n\nexport const T = (...list: ResultType[]): string => {\n  const value = mustOne(list);\n  return typeof value === 'string' ? value : '';\n};\n\nexport const LOWER = (...list: ResultType[]): string => {\n  const value = mustOneString(list);\n  return value.toLowerCase();\n};\nexport const CHAR = (...list: ResultType[]): string => {\n  const value = mustOneNumber(list);\n  return String.fromCharCode(value);\n};\nexport const CODE = (...list: ResultType[]): number => {\n  const value = mustOneString(list);\n  return value.charCodeAt(0);\n};\nexport const LEN = (...list: ResultType[]): number => {\n  const value = mustOneString(list);\n  return value.length;\n};\n\nexport const SPLIT = (...list: ResultType[]): string[] => {\n  assert(list.length === 2);\n  const [value, sep] = list;\n  assert(typeof value === 'string');\n  assert(typeof sep === 'string');\n  return value.split(sep);\n};\nexport const UPPER = (...list: ResultType[]): string => {\n  const value = mustOneString(list);\n  return value.toUpperCase();\n};\nexport const TRIM = (...list: ResultType[]): string => {\n  const value = mustOneString(list);\n  return value.replace(/ +/g, ' ').trim();\n};\nexport const CONCAT = (...list: ResultType[]): string => {\n  assert(list.length <= MAX_PARAMS_COUNT);\n  return list.join('');\n};\n\nconst formulas: TextFormulaType = {\n  CONCAT,\n  CONCATENATE: CONCAT,\n  SPLIT,\n  CHAR,\n  CODE,\n  UNICHAR: CHAR,\n  UNICODE: CODE,\n  LEN,\n  LOWER,\n  UPPER,\n  TRIM,\n  T,\n};\n\nexport default formulas;\n", "import { MAX_PARAMS_COUNT } from '@/util/constant';\nimport type { MathFormulaType, ResultType } from '../../types';\nimport { assert, mustOneNumber, mustEmpty } from './error';\nimport { parseNumber } from '@/util/util';\n\nfunction parseNumberArray(list: any[]): number[] {\n  const result: number[] = [];\n  for (let i = 0; i < list.length; i++) {\n    const [check, num] = parseNumber(list[i]);\n    if (check) {\n      result.push(num);\n    }\n  }\n  return result;\n}\n\nexport const ABS = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return Math.abs(data);\n};\nexport const ACOS = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return Math.acos(data);\n};\n\nexport const ACOSH = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return Math.log(data + Math.sqrt(data * data - 1));\n};\n\nexport const ACOT = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return Math.atan(1 / data);\n};\n\nexport const ACOTH = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return 0.5 * Math.log((data + 1) / (data - 1));\n};\nexport const ASIN = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return Math.asin(data);\n};\n\nexport const ASINH = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return Math.log(data + Math.sqrt(data * data + 1));\n};\nexport const ATAN = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return Math.atan(data);\n};\nexport const ATAN2 = (...list: ResultType[]): number => {\n  assert(list.length === 2);\n  const [x, y] = list;\n  assert(typeof x === 'number');\n  assert(typeof y === 'number');\n  return Math.atan2(x, y);\n};\nexport const ATANH = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return Math.log((1 + data) / (data + 1)) / 2;\n};\n\nexport const AVERAGE = (...rest: ResultType[]): number => {\n  const list = parseNumberArray(rest);\n  assert(list.length <= MAX_PARAMS_COUNT && list.length >= 1);\n  return list.reduce((sum, cur) => sum + cur, 0) / list.length;\n};\n\nexport const COS = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return Math.cos(data);\n};\nexport const COT = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return 1 / Math.tan(data);\n};\nexport const CSC = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return 1 / Math.sin(data);\n};\nexport const DECIMAL = (...list: ResultType[]): number => {\n  assert(list.length === 2);\n  const [data, radix] = list;\n  assert(typeof data === 'string');\n  assert(typeof radix === 'number');\n  return parseInt(data, radix);\n};\nexport const DEGREES = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return (data * 180) / Math.PI;\n};\nexport const EXP = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return Math.exp(data);\n};\nexport const INT = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return Math.floor(data);\n};\nexport const LN10 = (...list: ResultType[]): number => {\n  mustEmpty(list);\n  return Math.log(10);\n};\nexport const LN2 = (...list: ResultType[]): number => {\n  mustEmpty(list);\n  return Math.log(2);\n};\nexport const LOG10E = (...list: ResultType[]): number => {\n  mustEmpty(list);\n  return Math.LOG10E;\n};\nexport const LOG2E = (...list: ResultType[]): number => {\n  mustEmpty(list);\n  return Math.LOG2E;\n};\nexport const LOG = (...list: ResultType[]): number => {\n  assert(list.length >= 1 && list.length <= 2);\n  const [data, base = 10] = list;\n  assert(typeof data === 'number');\n  assert(typeof base === 'number');\n  return Math.log(data) / Math.log(base);\n};\n\nexport const LOG10 = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return Math.log(data) / Math.log(10);\n};\nexport const PI = (...list: ResultType[]): number => {\n  mustEmpty(list);\n  return Math.PI;\n};\nexport const E = (...list: ResultType[]): number => {\n  mustEmpty(list);\n  return Math.E;\n};\nexport const SIN = (...list: ResultType[]): number => {\n  const data = mustOneNumber(list);\n  return Math.sin(data);\n};\nexport const SUM = (...rest: ResultType[]): number => {\n  const list = parseNumberArray(rest);\n  assert(list.length <= MAX_PARAMS_COUNT);\n  return list.reduce((sum, cur) => sum + cur, 0);\n};\n\nconst formulas: MathFormulaType = {\n  ABS,\n  ACOS,\n  ACOSH,\n  ACOT,\n  ACOTH,\n  ASIN,\n  ASINH,\n  ATAN,\n  ATAN2,\n  ATANH,\n  AVERAGE,\n  COT,\n  COS,\n  EXP,\n  INT,\n  PI,\n  E,\n  SIN,\n  SUM,\n};\n\nexport default formulas;\n", "import { FORMULA_MAX_PRECISION } from '@/util/constant';\n\nexport function roundNumber(a: number) {\n  const temp = String(a);\n  const result = /[.](\\d*)/.exec(temp);\n  if (result && result[1]) {\n    const f = Math.pow(10, Math.min(result[1].length, FORMULA_MAX_PRECISION));\n    const list = temp.split('.');\n    const t = list[0] + list[1].slice(0, FORMULA_MAX_PRECISION);\n    return Number(t) / f;\n  } else {\n    return a;\n  }\n}\n", "import textFormulas from './text';\nimport mathFormulas from './math';\nimport type { FormulaType } from '@/types';\n\nconst allFormulas: FormulaType = {\n  ...textFormulas,\n  ...mathFormulas,\n};\nexport * from './error';\nexport default allFormulas;\nexport * from './float';\n", "import type { TokenType } from '@/types';\n\nexport class Token {\n  type: TokenType;\n  value: string;\n  constructor(type: TokenType, value: string) {\n    this.type = type;\n    this.value = value;\n  }\n  toString(): string {\n    return this.value;\n  }\n}\n", "/**\n * convert column name to number. e.g A -> 0, a -> 0\n * @param { string } columnName\n */\nexport function columnNameToInt(columnName: string): number {\n  const temp = columnName.toUpperCase();\n  let num = 0;\n  for (let i = 0; i < temp.length; i++) {\n    num = temp.charCodeAt(i) - 64 + num * 26;\n  }\n  return num - 1;\n}\n/**\n * convert number to column name 0 -> A\n * @param { string } number\n */\nexport function intToColumnName(temp: number): string {\n  const num = temp + 1;\n  let columnName = '';\n  let dividend = Math.floor(Math.abs(num));\n  let rest;\n\n  while (dividend > 0) {\n    rest = (dividend - 1) % 26;\n    columnName = String.fromCharCode(65 + rest) + columnName;\n    dividend = Math.floor((dividend - rest) / 26);\n  }\n  return columnName.toUpperCase();\n}\n\nexport function rowLabelToInt(label: string): number {\n  let result = parseInt(label, 10);\n  if (isNaN(result)) {\n    result = -1;\n  } else {\n    result = Math.max(result - 1, -1);\n  }\n  return result;\n}\n", "import { IRange, WorksheetType } from '@/types';\n\nexport function isSheet(range: IRange): boolean {\n  return isRow(range) && isCol(range);\n}\nexport function isRow(range: IRange): boolean {\n  return range.colCount === 0;\n}\nexport function isCol(range: IRange): boolean {\n  return range.rowCount === 0;\n}\n\nexport function isSameRange(oldRange: IRange, newRange: IRange): boolean {\n  return (\n    oldRange.col === newRange.col &&\n    oldRange.row === newRange.row &&\n    oldRange.colCount === newRange.colCount &&\n    oldRange.rowCount === newRange.rowCount &&\n    oldRange.sheetId === newRange.sheetId\n  );\n}\n\nexport function containRange(\n  sourceRange: IRange,\n  targetRange: IRange,\n): boolean {\n  if (sourceRange.colCount === 0 && targetRange.colCount !== 0) {\n    return false;\n  }\n  if (sourceRange.rowCount === 0 && targetRange.rowCount !== 0) {\n    return false;\n  }\n  if (targetRange.colCount === 0 && targetRange.row === sourceRange.row) {\n    return true;\n  }\n  if (targetRange.rowCount === 0 && targetRange.col === sourceRange.col) {\n    return true;\n  }\n  const { row, col } = sourceRange;\n  const check =\n    row >= targetRange.row &&\n    row < targetRange.row + targetRange.rowCount &&\n    col >= targetRange.col &&\n    col < targetRange.col + targetRange.colCount;\n  if (check) {\n    return true;\n  }\n\n  return false;\n}\n\nexport class SheetRange implements IRange {\n  row = 0;\n  col = 0;\n  colCount = 0;\n  rowCount = 0;\n  sheetId = '';\n  constructor(\n    row: number,\n    col: number,\n    rowCount: number,\n    colCount: number,\n    sheetId: string,\n  ) {\n    this.row = row;\n    this.col = col;\n    this.colCount = colCount;\n    this.rowCount = rowCount;\n    this.sheetId = sheetId;\n  }\n\n  static makeRange(range: IRange): SheetRange {\n    return new SheetRange(\n      range.row,\n      range.col,\n      range.rowCount,\n      range.colCount,\n      range.sheetId,\n    );\n  }\n  toIRange(): IRange {\n    return {\n      row: this.row,\n      col: this.col,\n      rowCount: this.rowCount,\n      colCount: this.colCount,\n      sheetId: this.sheetId,\n    };\n  }\n}\n\nexport function iterateRange(\n  range: IRange,\n  sheetInfo: WorksheetType | undefined,\n  fn: (row: number, col: number) => boolean,\n) {\n  const { row, col, rowCount, colCount } = range;\n  if (!sheetInfo) {\n    return;\n  }\n  if (isSheet(range)) {\n    for (let r = 0; r < sheetInfo.rowCount; r++) {\n      for (let c = 0; c < sheetInfo.colCount; c++) {\n        if (fn(r, c)) {\n          return;\n        }\n      }\n    }\n    return;\n  }\n  if (isRow(range)) {\n    for (let i = 0; i < sheetInfo.colCount; i++) {\n      if (fn(row, i)) {\n        return;\n      }\n    }\n    return;\n  }\n  if (isCol(range)) {\n    for (let i = 0; i < sheetInfo.rowCount; i++) {\n      if (fn(i, col)) {\n        return;\n      }\n    }\n    return;\n  }\n\n  const endRow = row + rowCount;\n  const endCol = col + colCount;\n  for (let r = row; r < endRow; r++) {\n    for (let c = col; c < endCol; c++) {\n      if (fn(r, c)) {\n        return;\n      }\n    }\n  }\n}\n", "import { columnNameToInt, rowLabelToInt, intToColumnName } from './convert';\nimport { Coordinate, IRange, ReferenceType } from '@/types';\nimport { SheetRange } from './range';\nimport { XLSX_MAX_COL_COUNT, XLSX_MAX_ROW_COUNT } from './constant';\n\nexport const isAlpha = (char: string) =>\n  (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z');\nexport const isDigit = (char: string) => char >= '0' && char <= '9';\n\nfunction convertSheetNameToSheetId(value: string) {\n  return value;\n}\n\nfunction parseCell(\n  ref: string,\n  convertSheetName: typeof convertSheetNameToSheetId,\n): SheetRange | undefined {\n  if (!ref) {\n    return undefined;\n  }\n  const realRef = ref.trim();\n  let [sheetName, other = ''] = realRef.split('!');\n  if (!realRef.includes('!')) {\n    sheetName = '';\n    other = realRef;\n  }\n  if (\n    sheetName &&\n    sheetName[0] === \"'\" &&\n    sheetName[sheetName.length - 1] === \"'\"\n  ) {\n    sheetName = sheetName.slice(1, -1);\n  }\n  let i = 0;\n  let rowText = '';\n  let colText = '';\n  if (other[i] === '$') {\n    i++;\n  }\n  while (i < other.length && isAlpha(other[i])) {\n    colText += other[i++];\n  }\n  if (other[i] === '$') {\n    i++;\n  }\n  while (i < other.length && isDigit(other[i])) {\n    rowText += other[i++];\n  }\n  if (i !== other.length) {\n    return undefined;\n  }\n  if (!rowText && !colText) {\n    return undefined;\n  }\n\n  let rowCount = 1;\n  let colCount = 1;\n  let row = -1;\n  let col = -1;\n  if (rowText === '') {\n    rowCount = 0;\n    row = 0;\n  } else {\n    row = rowLabelToInt(rowText);\n  }\n  if (colText === '') {\n    colCount = 0;\n    col = 0;\n  } else {\n    col = columnNameToInt(colText);\n  }\n  if (\n    row < 0 ||\n    col < 0 ||\n    col >= XLSX_MAX_COL_COUNT ||\n    row >= XLSX_MAX_ROW_COUNT\n  ) {\n    return undefined;\n  }\n  const range = new SheetRange(\n    row,\n    col,\n    rowCount,\n    colCount,\n    convertSheetName(sheetName),\n  );\n  return range;\n}\n\nexport function parseReference(\n  text: string,\n  convertSheetName = convertSheetNameToSheetId,\n): SheetRange | undefined {\n  const [cell1, cell2] = text.split(':');\n  const startCell = parseCell(cell1, convertSheetName);\n  if (!startCell) {\n    return undefined;\n  }\n  const endCell = parseCell(cell2, convertSheetName);\n  if (!endCell) {\n    return startCell;\n  }\n  endCell.sheetId = startCell.sheetId;\n  return mergeRange(startCell, endCell);\n}\n\nexport function mergeRange(\n  start: SheetRange,\n  end: SheetRange,\n): SheetRange | undefined {\n  if (start.sheetId !== end.sheetId) {\n    return undefined;\n  }\n  if (\n    start.row === end.row &&\n    start.col === end.col &&\n    start.rowCount === end.rowCount &&\n    start.colCount === end.colCount\n  ) {\n    return start;\n  }\n  if (start.rowCount === 0 && end.rowCount !== 0) {\n    return undefined;\n  }\n  if (start.rowCount !== 0 && end.rowCount === 0) {\n    return undefined;\n  }\n  if (start.colCount === 0 && end.colCount !== 0) {\n    return undefined;\n  }\n  if (start.colCount !== 0 && end.colCount === 0) {\n    return undefined;\n  }\n\n  const rowCount = Math.abs(start.row - end.row) + 1;\n  const colCount = Math.abs(start.col - end.col) + 1;\n  const row = start.row < end.row ? start.row : end.row;\n  const col = start.col < end.col ? start.col : end.col;\n\n  return new SheetRange(row, col, rowCount, colCount, start.sheetId);\n}\n\nfunction convertCell(row: number, col: number, referenceType: ReferenceType) {\n  const first = referenceType === 'absolute' || referenceType === 'mixed';\n  const second = referenceType === 'absolute';\n  return `${first ? '$' : ''}${intToColumnName(col)}${second ? '$' : ''}${\n    row + 1\n  }`;\n}\n\nexport function convertToReference(\n  range: IRange,\n  referenceType: ReferenceType = 'relative',\n  convertSheetIdToSheetName = convertSheetNameToSheetId,\n) {\n  let result = convertCell(range.row, range.col, referenceType);\n  let sheetName = convertSheetIdToSheetName(range.sheetId);\n  sheetName = sheetName ? `${sheetName}!` : '';\n  if (range.colCount > 1 && range.rowCount > 1) {\n    const end = convertCell(\n      range.row + range.rowCount - 1,\n      range.col + range.colCount - 1,\n      referenceType,\n    );\n    result = `${result}:${end}`;\n  }\n  return sheetName + result;\n}\n\nexport const R1C1_REG = /^R(\\[-\\d+\\]|\\[\\d+\\]|\\d+)?C(\\[-\\d+\\]|\\[\\d+\\]|\\d+)?$/i;\n\nfunction parseNumber(text: string, num: number) {\n  let result = -1;\n  if (text.startsWith('[')) {\n    const t = parseInt(text.slice(1, -1), 10);\n    if (!isNaN(t)) {\n      result = num + t;\n    }\n  } else {\n    const t = parseInt(text, 10);\n    if (!isNaN(t)) {\n      result = t - 1;\n    }\n  }\n  return isNaN(result) ? -1 : result;\n}\n\nexport function parseR1C1(\n  name: string,\n  activeCell: Coordinate = { row: -1, col: -1 },\n): SheetRange | undefined {\n  const text = name.toUpperCase();\n  if (text[0] !== 'R') {\n    return undefined;\n  }\n  const list = text.slice(1).split('C');\n  if (list.length !== 2) {\n    return undefined;\n  }\n  const [rowText, colText] = list;\n  let row = -1;\n  let col = -1;\n  if (!rowText) {\n    row = activeCell.row;\n  } else {\n    row = parseNumber(rowText, activeCell.row);\n  }\n  if (!colText) {\n    col = activeCell.col;\n  } else {\n    col = parseNumber(colText, activeCell.col);\n  }\n  if (\n    col >= XLSX_MAX_COL_COUNT ||\n    row >= XLSX_MAX_ROW_COUNT ||\n    row < 0 ||\n    col < 0\n  ) {\n    return undefined;\n  }\n  const range = new SheetRange(row, col, 1, 1, '');\n  return range;\n}\n", "import { TokenType } from '@/types';\nimport { Token } from './token';\nimport { CustomError } from './formula';\nimport { FORMULA_PREFIX } from '@/util/constant';\nimport { isDigit, isAlpha } from '@/util/reference';\n\nconst emptyData = '';\nconst identifierMap = new Map<string, TokenType>([\n  ['TRUE', TokenType.TRUE],\n  ['FALSE', TokenType.FALSE],\n]);\n\nexport class Scanner {\n  private readonly list: string[];\n  private current = 0;\n  private start = 0;\n  private readonly tokens: Token[] = [];\n  constructor(source: string) {\n    this.list = [...source];\n  }\n  scan(): Token[] {\n    while (!this.isAtEnd()) {\n      this.start = this.current;\n      this.scanToken();\n    }\n    this.tokens.push(new Token(TokenType.EOF, ''));\n    if (this.tokens.length > 0 && this.tokens[0].type === TokenType.EQUAL) {\n      this.tokens.shift();\n    }\n    return this.tokens;\n  }\n  private peek() {\n    if (this.isAtEnd()) {\n      return emptyData;\n    }\n    return this.list[this.current];\n  }\n  private match(text: string) {\n    if (this.peek() !== text) {\n      return false;\n    }\n    this.next();\n    return true;\n  }\n  private next() {\n    if (this.isAtEnd()) {\n      return emptyData;\n    }\n    return this.list[this.current++];\n  }\n  private isAtEnd() {\n    return this.current >= this.list.length;\n  }\n  private addToken(type: TokenType) {\n    const text = this.list.slice(this.start, this.current).join('');\n    this.tokens.push(new Token(type, text));\n  }\n  private string(end: string) {\n    while (!this.isAtEnd() && this.peek() !== end) {\n      this.next();\n    }\n    if (this.peek() !== end) {\n      throw new CustomError('#VALUE!');\n    } else {\n      this.next();\n    }\n    const text = this.list.slice(this.start + 1, this.current - 1).join('');\n    this.tokens.push(new Token(TokenType.STRING, text));\n  }\n  private getDigits() {\n    while (!this.isAtEnd() && isDigit(this.peek())) {\n      this.next();\n    }\n  }\n  private getAlphas() {\n    while (!this.isAtEnd() && isAlpha(this.peek())) {\n      this.next();\n    }\n  }\n  private matchR1C1() {\n    if (this.match('[')) {\n      this.match('-');\n      if (isDigit(this.peek())) {\n        this.getDigits();\n      } else {\n        throw new CustomError('#VALUE!');\n      }\n      if (this.peek() !== ']') {\n        throw new CustomError('#VALUE!');\n      } else {\n        this.next();\n      }\n    } else {\n      this.getDigits();\n    }\n  }\n  private matchScientificCounting(isFloat: boolean) {\n    if (this.match('E') || this.match('e')) {\n      // 1E-10 1E+10\n      if (this.match('+') || this.match('-')) {\n        this.getDigits();\n        this.addToken(isFloat ? TokenType.FLOAT : TokenType.INTEGER);\n        return true;\n      }\n      if (isDigit(this.peek())) {\n        this.getDigits();\n        this.addToken(isFloat ? TokenType.FLOAT : TokenType.INTEGER);\n        return true;\n      }\n      // 1E or 1.1E not valid\n      throw new CustomError('#VALUE!');\n    }\n    return false;\n  }\n  private number() {\n    this.getDigits();\n    const check1 = this.matchScientificCounting(false);\n    if (check1) {\n      return;\n    }\n    let float = false;\n    if (this.match('.')) {\n      float = true;\n      this.getDigits();\n    }\n    const check2 = this.matchScientificCounting(true);\n    if (check2) {\n      return;\n    }\n    this.addToken(float ? TokenType.FLOAT : TokenType.INTEGER);\n  }\n  private addIdentifier() {\n    while (!this.isAtEnd() && this.anyChar(this.peek())) {\n      this.next();\n    }\n    let text = this.list.slice(this.start, this.current).join('');\n    const t = text.toUpperCase();\n    const temp = identifierMap.get(t);\n    let type: TokenType = TokenType.IDENTIFIER;\n    if (temp) {\n      text = t;\n      type = temp;\n    }\n    if (/^[A-Z]+\\$\\d+$/.test(t)) {\n      text = t;\n      type = TokenType.MIXED_CELL;\n    }\n\n    this.tokens.push(new Token(type, text));\n  }\n  private scanToken() {\n    const c = this.next();\n    switch (c) {\n      case '$': {\n        if (isAlpha(this.peek())) {\n          this.getAlphas();\n          if (this.match('$')) {\n            if (isDigit(this.peek())) {\n              // $A$1 absolute reference\n              this.getDigits();\n              this.addToken(TokenType.ABSOLUTE_CELL);\n            } else {\n              this.addIdentifier();\n            }\n          } else if (isDigit(this.peek())) {\n            // $A1 mixed reference\n            this.getDigits();\n            this.addToken(TokenType.MIXED_CELL);\n          } else {\n            // $A\n            this.addToken(TokenType.ABSOLUTE_CELL);\n          }\n        } else if (isDigit(this.peek())) {\n          // $1 absolute reference\n          this.getDigits();\n          this.addToken(TokenType.ABSOLUTE_CELL);\n        } else {\n          this.addIdentifier();\n        }\n        break;\n      }\n      case 'r':\n      case 'R': {\n        this.matchR1C1();\n        if (this.match('C') || this.match('c')) {\n          this.matchR1C1();\n          const text = this.list\n            .slice(this.start, this.current)\n            .join('')\n            .toUpperCase();\n          this.tokens.push(new Token(TokenType.R1C1, text));\n        } else {\n          this.addIdentifier();\n        }\n        break;\n      }\n      case '(':\n        this.addToken(TokenType.LEFT_BRACKET);\n        break;\n      case ')':\n        this.addToken(TokenType.RIGHT_BRACKET);\n        break;\n      case ',':\n        this.addToken(TokenType.COMMA);\n        break;\n      case ':':\n        this.addToken(TokenType.COLON);\n        break;\n      case FORMULA_PREFIX:\n        this.addToken(TokenType.EQUAL);\n        break;\n      case '<':\n        if (this.match('>')) {\n          this.addToken(TokenType.NOT_EQUAL);\n        } else if (this.match('=')) {\n          this.addToken(TokenType.LESS_EQUAL);\n        } else {\n          this.addToken(TokenType.LESS);\n        }\n        break;\n      case '>':\n        if (this.match('=')) {\n          this.addToken(TokenType.GREATER_EQUAL);\n        } else {\n          this.addToken(TokenType.GREATER);\n        }\n        break;\n      case '+':\n        this.addToken(TokenType.PLUS);\n        break;\n      case '-':\n        this.addToken(TokenType.MINUS);\n        break;\n      case '*':\n        this.addToken(TokenType.STAR);\n        break;\n      case '/':\n        this.addToken(TokenType.SLASH);\n        break;\n      case '^':\n        this.addToken(TokenType.EXPONENT);\n        break;\n      case '&':\n        this.addToken(TokenType.CONCATENATE);\n        break;\n      case '%':\n        this.addToken(TokenType.PERCENT);\n        break;\n      case '\"':\n        this.string(c);\n        break;\n      case \"'\":\n        this.string(c);\n        break;\n      case '!':\n        this.addToken(TokenType.EXCLAMATION);\n        break;\n      case ';':\n        this.addToken(TokenType.SEMICOLON);\n        break;\n      case '{':\n        this.addToken(TokenType.lEFT_BRACE);\n        break;\n      case '}':\n        this.addToken(TokenType.RIGHT_BRACE);\n        break;\n      case ' ':\n        // while (!this.isAtEnd() && this.peek() === ' ') {\n        // this.next();\n        // }\n        // this.addToken(TokenType.EMPTY_CHAR);\n        break;\n      case '\\r':\n      case '\\t':\n      case '\\n':\n        break;\n      default:\n        if (isDigit(c)) {\n          this.number();\n        } else if (this.anyChar(c)) {\n          this.addIdentifier();\n        } else {\n          throw new CustomError('#ERROR!');\n        }\n        break;\n    }\n  }\n  private anyChar(c: string) {\n    const text = '(),:=<>+-*/^&%\"{}!';\n    return !text.includes(c) && !this.isWhiteSpace(c);\n  }\n  private isWhiteSpace(c: string) {\n    return c === ' ' || c === '\\r' || c === '\\n' || c === '\\t';\n  }\n}\n", "import type { Token } from './token';\nimport type { ReferenceType } from '@/types';\nimport { TokenType } from '@/types';\n\nexport interface Visitor {\n  visitBinaryExpression: (expr: BinaryExpression) => any;\n  visitUnaryExpression: (expr: UnaryExpression) => any;\n  visitPostUnaryExpression: (expr: PostUnaryExpression) => any;\n  visitLiteralExpression: (expr: LiteralExpression) => any;\n  visitCellExpression: (expr: CellExpression) => any;\n  visitR1C1Expression: (expr: R1C1Expression) => any;\n  visitCellRangeExpression: (expr: CellRangeExpression) => any;\n  visitCallExpression: (expr: CallExpression) => any;\n  visitGroupExpression: (expr: GroupExpression) => any;\n  visitTokenExpression: (expr: TokenExpression) => any;\n}\n\nexport interface Expression {\n  accept: (visitor: Visitor) => any;\n  toString: () => string;\n}\n\nexport class BinaryExpression implements Expression {\n  readonly left: Expression;\n  readonly right: Expression;\n  readonly operator: Token;\n  constructor(left: Expression, operator: Token, right: Expression) {\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n  accept(visitor: Visitor) {\n    return visitor.visitBinaryExpression(this);\n  }\n  private handleConcatenate(value: Expression): string {\n    const result = value.toString();\n    const check =\n      this.operator.type === TokenType.CONCATENATE &&\n      value instanceof LiteralExpression &&\n      value.value.type === TokenType.STRING;\n    if (check) {\n      return JSON.stringify(result);\n    }\n    return result;\n  }\n  toString(): string {\n    const left = this.handleConcatenate(this.left);\n    const right = this.handleConcatenate(this.right);\n    return `${left}${this.operator.toString()}${right}`;\n  }\n}\n\nexport class UnaryExpression implements Expression {\n  readonly right: Expression;\n  readonly operator: Token;\n  constructor(operator: Token, right: Expression) {\n    this.operator = operator;\n    this.right = right;\n  }\n  accept(visitor: Visitor) {\n    return visitor.visitUnaryExpression(this);\n  }\n  toString(): string {\n    return this.operator.toString() + this.right.toString();\n  }\n}\n\nexport class PostUnaryExpression implements Expression {\n  readonly left: Expression;\n  readonly operator: Token;\n  constructor(operator: Token, left: Expression) {\n    this.operator = operator;\n    this.left = left;\n  }\n  accept(visitor: Visitor) {\n    return visitor.visitPostUnaryExpression(this);\n  }\n  toString(): string {\n    return this.left.toString() + this.operator.toString();\n  }\n}\n\nexport class LiteralExpression implements Expression {\n  readonly value: Token;\n  constructor(value: Token) {\n    this.value = value;\n  }\n  accept(visitor: Visitor) {\n    return visitor.visitLiteralExpression(this);\n  }\n  toString(): string {\n    return this.value.toString();\n  }\n}\n\nexport class R1C1Expression implements Expression {\n  readonly value: Token;\n  constructor(value: Token) {\n    this.value = value;\n  }\n  accept(visitor: Visitor) {\n    return visitor.visitR1C1Expression(this);\n  }\n  toString(): string {\n    return this.value.toString();\n  }\n}\nexport class CellExpression implements Expression {\n  readonly value: Token;\n  readonly sheetName: Token | undefined;\n  readonly type: ReferenceType;\n  constructor(value: Token, type: ReferenceType, sheetName: Token | undefined) {\n    this.value = value;\n    this.sheetName = sheetName;\n    this.type = type;\n  }\n  accept(visitor: Visitor) {\n    return visitor.visitCellExpression(this);\n  }\n  toString(): string {\n    const t = this.value.toString().toUpperCase();\n    if (this.sheetName) {\n      let name = this.sheetName.toString();\n      if (name.includes(' ')) {\n        name = `'${name}'`;\n      }\n      return `${name}!${t}`;\n    } else {\n      return t;\n    }\n  }\n}\n\nexport class CallExpression implements Expression {\n  readonly name: Expression;\n  readonly params: Expression[];\n  constructor(name: Expression, params: Expression[]) {\n    this.name = name;\n    this.params = params;\n  }\n  accept(visitor: Visitor) {\n    return visitor.visitCallExpression(this);\n  }\n  toString(): string {\n    return `${this.name.toString().toUpperCase()}(${this.params\n      .map((item) => item.toString())\n      .join(',')})`;\n  }\n}\n\nexport class CellRangeExpression implements Expression {\n  readonly right: CellExpression;\n  readonly operator: Token;\n  readonly left: CellExpression;\n  constructor(left: CellExpression, operator: Token, right: CellExpression) {\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n  accept(visitor: Visitor) {\n    return visitor.visitCellRangeExpression(this);\n  }\n  toString(): string {\n    return (\n      this.left.toString() + this.operator.toString() + this.right.toString()\n    );\n  }\n}\n\nexport class GroupExpression implements Expression {\n  readonly value: Expression;\n  constructor(value: Expression) {\n    this.value = value;\n  }\n  accept(visitor: Visitor) {\n    return visitor.visitGroupExpression(this);\n  }\n  toString(): string {\n    return `(${this.value.toString()})`;\n  }\n}\n\nexport class TokenExpression implements Expression {\n  readonly value: Token;\n  constructor(value: Token) {\n    this.value = value;\n  }\n  accept(visitor: Visitor) {\n    return visitor.visitTokenExpression(this);\n  }\n  toString(): string {\n    return this.value.toString();\n  }\n}\n", "import { TokenType, ErrorTypes } from '@/types';\nimport { Token } from './token';\nimport {\n  TokenExpression,\n  Expression,\n  GroupExpression,\n  PostUnaryExpression,\n  BinaryExpression,\n  UnaryExpression,\n  CallExpression,\n  LiteralExpression,\n  CellRangeExpression,\n  R1C1Expression,\n  CellExpression,\n} from './expression';\nimport { CustomError, isRelativeReference } from './formula';\nimport { ERROR_SET } from '@/util/constant';\n\nexport class Parser {\n  private readonly tokens: Token[];\n  private current = 0;\n  constructor(tokens: Token[]) {\n    this.tokens = tokens;\n  }\n  parse(): Expression[] {\n    const result: Expression[] = [];\n    while (!this.isAtEnd()) {\n      result.push(this.expression());\n    }\n    return result;\n  }\n  private expression(): Expression {\n    return this.comparison();\n  }\n  private comparison(): Expression {\n    let expr = this.concatenate();\n    while (\n      this.match(\n        TokenType.EQUAL,\n        TokenType.NOT_EQUAL,\n        TokenType.GREATER,\n        TokenType.GREATER_EQUAL,\n        TokenType.LESS,\n        TokenType.LESS_EQUAL,\n      )\n    ) {\n      const operator = this.previous();\n      const right = this.concatenate();\n      expr = new BinaryExpression(expr, operator, right);\n    }\n    return expr;\n  }\n  private concatenate(): Expression {\n    let expr = this.term();\n    while (this.match(TokenType.CONCATENATE)) {\n      const operator = this.previous();\n      const right = this.term();\n      expr = new BinaryExpression(expr, operator, right);\n    }\n    return expr;\n  }\n  private term(): Expression {\n    let expr = this.factor();\n    while (this.match(TokenType.PLUS, TokenType.MINUS)) {\n      const operator = this.previous();\n      const right = this.factor();\n      expr = new BinaryExpression(expr, operator, right);\n    }\n    return expr;\n  }\n  private factor(): Expression {\n    let expr = this.expo();\n    while (this.match(TokenType.SLASH, TokenType.STAR)) {\n      const operator = this.previous();\n      const right = this.expo();\n      expr = new BinaryExpression(expr, operator, right);\n    }\n    return expr;\n  }\n  private expo(): Expression {\n    let expr = this.unary();\n    while (this.match(TokenType.EXPONENT)) {\n      const operator = this.previous();\n      const right = this.unary();\n      expr = new BinaryExpression(expr, operator, right);\n    }\n    return expr;\n  }\n\n  private unary(): Expression {\n    if (this.match(TokenType.PLUS, TokenType.MINUS)) {\n      const operator = this.previous();\n      const right = this.unary();\n      return new UnaryExpression(operator, right);\n    }\n    return this.postUnary();\n  }\n  private postUnary(): Expression {\n    let expr = this.cellRange();\n    if (this.match(TokenType.PERCENT)) {\n      const operator = this.previous();\n      expr = new PostUnaryExpression(operator, expr);\n    }\n    return expr;\n  }\n  private cellRange(): Expression {\n    let expr = this.sheetRange();\n    while (this.match(TokenType.COLON)) {\n      const operator = this.previous();\n      const right = this.sheetRange();\n      const realRight = this.convertToCellExpression(right);\n      const realLeft = this.convertToCellExpression(expr);\n      expr = new CellRangeExpression(realLeft, operator, realRight);\n    }\n    return expr;\n  }\n  private convertToCellExpression(expr: Expression): CellExpression {\n    if (expr instanceof CellExpression) {\n      return expr;\n    }\n    if (\n      expr instanceof TokenExpression &&\n      isRelativeReference(expr.value.value)\n    ) {\n      return new CellExpression(expr.value, 'relative', undefined);\n    }\n    if (\n      expr instanceof LiteralExpression &&\n      expr.value.type === TokenType.INTEGER\n    ) {\n      return new CellExpression(expr.value, 'relative', undefined);\n    }\n    throw new CustomError('#NAME?');\n  }\n  private sheetRange(): Expression {\n    let expr = this.call();\n    if (this.match(TokenType.EXCLAMATION)) {\n      const right = this.call();\n      if (\n        expr instanceof TokenExpression ||\n        expr instanceof LiteralExpression\n      ) {\n        const cell = this.convertToCellExpression(right);\n        return new CellExpression(cell.value, cell.type, expr.value);\n      }\n    }\n    return expr;\n  }\n  private call(): Expression {\n    let expr = this.primary();\n    while (1) {\n      if (this.match(TokenType.LEFT_BRACKET)) {\n        expr = this.finishCall(expr);\n      } else {\n        break;\n      }\n    }\n    return expr;\n  }\n\n  private finishCall(name: Expression): CallExpression {\n    const params: Expression[] = [];\n    if (!this.check(TokenType.RIGHT_BRACKET)) {\n      do {\n        // fix SUM(1,)\n        if (this.peek().type == TokenType.RIGHT_BRACKET) {\n          break;\n        }\n        params.push(this.expression());\n      } while (this.match(TokenType.COMMA));\n    }\n    this.expect(TokenType.RIGHT_BRACKET);\n    return new CallExpression(name, params);\n  }\n  private primary(): Expression {\n    if (this.match(TokenType.LEFT_BRACKET)) {\n      const value = this.expression();\n      this.expect(TokenType.RIGHT_BRACKET);\n      return new GroupExpression(value);\n    }\n    if (\n      this.match(\n        TokenType.INTEGER,\n        TokenType.FLOAT,\n        TokenType.STRING,\n        TokenType.TRUE,\n        TokenType.FALSE,\n      )\n    ) {\n      return new LiteralExpression(this.previous());\n    }\n    if (this.match(TokenType.ABSOLUTE_CELL)) {\n      const token = this.previous();\n      return new CellExpression(token, 'absolute', undefined);\n    }\n    if (this.match(TokenType.MIXED_CELL)) {\n      const token = this.previous();\n      return new CellExpression(token, 'mixed', undefined);\n    }\n\n    if (this.match(TokenType.IDENTIFIER)) {\n      const name = this.previous();\n      const realValue = name.value.toUpperCase();\n      if (ERROR_SET.has(realValue as ErrorTypes)) {\n        throw new CustomError(realValue as ErrorTypes);\n      }\n      return new TokenExpression(name);\n    }\n    if (this.match(TokenType.R1C1)) {\n      return new R1C1Expression(this.previous());\n    }\n\n    throw new CustomError('#ERROR!');\n  }\n  private match(...types: TokenType[]): boolean {\n    const { type } = this.peek();\n    if (types.includes(type)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  private previous(): Token {\n    return this.tokens[this.current - 1];\n  }\n  private check(type: TokenType): boolean {\n    return this.peek().type === type;\n  }\n  private expect(type: TokenType): Token {\n    if (this.check(type)) {\n      this.next();\n      return this.previous();\n    } else {\n      throw new CustomError('#ERROR!');\n    }\n  }\n  private next() {\n    this.current++;\n  }\n  private isAtEnd() {\n    return this.peek().type === TokenType.EOF;\n  }\n  private peek(): Token {\n    if (this.current < this.tokens.length) {\n      return this.tokens[this.current];\n    }\n    return new Token(TokenType.EOF, '');\n  }\n}\n", "import { SheetRange } from '@/util/range';\nimport { mergeRange, parseReference, parseR1C1 } from '@/util/reference';\nimport { parseNumber } from '@/util/util';\nimport {\n  TokenType,\n  CellDataMap,\n  DefinedNamesMap,\n  FormulaType,\n  FormulaKeys,\n  ResultType,\n} from '@/types';\nimport type {\n  Visitor,\n  Expression,\n  CellRangeExpression,\n  PostUnaryExpression,\n  R1C1Expression,\n} from './expression';\nimport {\n  BinaryExpression,\n  UnaryExpression,\n  CellExpression,\n  CallExpression,\n  LiteralExpression,\n  TokenExpression,\n  GroupExpression,\n} from './expression';\nimport { CustomError, assert, isRelativeReference } from './formula';\n\nexport class Interpreter implements Visitor {\n  private readonly expressions: Expression[];\n  private readonly functionMap: FormulaType;\n  private readonly cellDataMap: CellDataMap;\n  private readonly definedNamesMap: DefinedNamesMap;\n  constructor(\n    expressions: Expression[],\n    cellDataMap: CellDataMap,\n    definedNamesMap: DefinedNamesMap,\n    functionMap: FormulaType,\n  ) {\n    this.expressions = expressions;\n    this.functionMap = functionMap;\n    this.cellDataMap = cellDataMap;\n    this.definedNamesMap = definedNamesMap;\n  }\n  interpret(): ResultType {\n    const result: ResultType[] = [];\n    for (const item of this.expressions) {\n      result.push(this.evaluate(item));\n    }\n    if (result.length === 1) {\n      return this.getRangeCellValue(result[0]);\n    } else {\n      throw new CustomError('#ERROR!');\n    }\n  }\n\n  visitBinaryExpression(data: BinaryExpression): any {\n    let left = this.evaluate(data.left);\n    let right = this.evaluate(data.right);\n    left = this.getRangeCellValue(left);\n    right = this.getRangeCellValue(right);\n    switch (data.operator.type) {\n      case TokenType.MINUS:\n        assert(typeof left === 'number');\n        assert(typeof right === 'number');\n        return left - right;\n      case TokenType.PLUS:\n        assert(typeof left === 'number');\n        assert(typeof right === 'number');\n        return left + right;\n      case TokenType.SLASH:\n        assert(typeof left === 'number');\n        assert(typeof right === 'number');\n        if (right === 0) {\n          throw new CustomError('#DIV/0!');\n        }\n        return left / right;\n      case TokenType.STAR:\n        assert(typeof left === 'number');\n        assert(typeof right === 'number');\n        return left * right;\n      case TokenType.EXPONENT:\n        assert(typeof left === 'number');\n        assert(typeof right === 'number');\n        return Math.pow(left, right);\n      case TokenType.EQUAL:\n        return left === right;\n      case TokenType.NOT_EQUAL:\n        return left !== right;\n      case TokenType.GREATER:\n        return left > right;\n      case TokenType.GREATER_EQUAL:\n        return left >= right;\n      case TokenType.LESS:\n        return left < right;\n      case TokenType.LESS_EQUAL:\n        return left <= right;\n      case TokenType.CONCATENATE:\n        return `${left}${right}`;\n      default:\n        throw new CustomError('#VALUE!');\n    }\n  }\n  visitCallExpression(expr: CallExpression) {\n    const callee = this.evaluate(expr.name);\n    if (callee && typeof callee === 'function') {\n      let params: ResultType[] = [];\n      for (const item of expr.params) {\n        const t = this.evaluate(item);\n        if (t instanceof SheetRange) {\n          const list = this.cellDataMap.get(t);\n          params = params.concat(list);\n        } else {\n          params.push(t);\n        }\n      }\n      return callee(...params);\n    }\n    throw new CustomError('#NAME?');\n  }\n  visitR1C1Expression(data: R1C1Expression) {\n    const range = parseR1C1(\n      data.value.value,\n      this.cellDataMap.getCurrentCell(),\n    );\n    if (!range) {\n      throw new CustomError('#NAME?');\n    }\n    return range;\n  }\n  visitCellExpression(data: CellExpression) {\n    let sheetId = '';\n    if (data.sheetName) {\n      sheetId = this.cellDataMap.convertSheetNameToSheetId(\n        data.sheetName.value,\n      );\n      if (!sheetId) {\n        throw new CustomError('#NAME?');\n      }\n    }\n    const range = parseReference(data.value.value);\n    if (!range) {\n      throw new CustomError('#NAME?');\n    }\n    if (sheetId) {\n      range.sheetId = sheetId;\n    }\n    return range;\n  }\n  visitLiteralExpression(expr: LiteralExpression) {\n    const { type, value } = expr.value;\n    switch (type) {\n      case TokenType.STRING:\n        return value;\n      case TokenType.FLOAT:\n      case TokenType.INTEGER: {\n        const [check, num] = parseNumber(value);\n        if (check) {\n          return num;\n        }\n        throw new CustomError('#VALUE!');\n      }\n      case TokenType.TRUE:\n        return true;\n      case TokenType.FALSE:\n        return false;\n      default:\n        throw new CustomError('#ERROR!');\n    }\n  }\n\n  visitTokenExpression(expr: TokenExpression) {\n    const { value } = expr.value;\n    const defineName = value.toLowerCase();\n    if (this.definedNamesMap.get(defineName)) {\n      const temp = this.definedNamesMap.get(defineName)!;\n      return this.cellDataMap.get(temp)[0];\n    }\n    const funcName = value.toUpperCase();\n    const func = this.functionMap[funcName as FormulaKeys];\n    if (func) {\n      return func;\n    }\n    if (isRelativeReference(value)) {\n      return this.visitCellExpression(\n        new CellExpression(expr.value, 'relative', undefined),\n      );\n    }\n    throw new CustomError('#NAME?');\n  }\n  visitUnaryExpression(data: UnaryExpression): any {\n    const value = this.evaluate(data.right);\n    switch (data.operator.type) {\n      case TokenType.MINUS:\n        assert(typeof value === 'number');\n        return -value;\n      case TokenType.PLUS:\n        assert(typeof value === 'number');\n        return value;\n      default:\n        throw new CustomError('#VALUE!');\n    }\n  }\n\n  visitCellRangeExpression(expr: CellRangeExpression): any {\n    switch (expr.operator.type) {\n      case TokenType.COLON: {\n        const a = this.visitCellExpression(expr.left);\n        const b = this.visitCellExpression(expr.right);\n        const result = mergeRange(a, b);\n        if (!result) {\n          throw new CustomError('#NAME?');\n        }\n        return result;\n      }\n      default:\n        throw new CustomError('#NAME?');\n    }\n  }\n  visitGroupExpression(expr: GroupExpression): any {\n    return this.evaluate(expr.value);\n  }\n  visitPostUnaryExpression(expr: PostUnaryExpression): any {\n    const value = this.evaluate(expr.left);\n    switch (expr.operator.type) {\n      case TokenType.PERCENT:\n        assert(typeof value === 'number');\n        return value * 0.01;\n      default:\n        throw new CustomError('#VALUE!');\n    }\n  }\n  private evaluate(expr: Expression) {\n    return expr.accept(this);\n  }\n  private getRangeCellValue(value: any): ResultType {\n    if (value instanceof SheetRange) {\n      if (value.colCount === value.rowCount && value.colCount === 1) {\n        const list = this.cellDataMap.get(value);\n        return list[0];\n      } else {\n        throw new CustomError('#REF!');\n      }\n    }\n    return value;\n  }\n}\n", "import { Scanner } from './scanner';\nimport { Parser } from './parser';\nimport allFormulas, { CustomError, roundNumber } from './formula';\nimport { Interpreter } from './interpreter';\nimport {\n  CellDataMap,\n  InterpreterResult,\n  DefinedNamesMap,\n  IRange,\n  FormulaType,\n  ResultType,\n  Coordinate,\n} from '@/types';\n\nexport function parseFormula(\n  source: string,\n  cellData: CellDataMap = new CellDataMapImpl(),\n  definedNamesMap: DefinedNamesMap = new DefinedNamesMapImpl(),\n  functionMap: FormulaType = allFormulas,\n): InterpreterResult {\n  let expressionStr = '';\n  try {\n    const list = new Scanner(source).scan();\n    const expressions = new Parser(list).parse();\n    const result = new Interpreter(\n      expressions,\n      cellData,\n      definedNamesMap,\n      functionMap,\n    ).interpret();\n\n    const strList: string[] = [];\n    for (const item of expressions) {\n      strList.push(item.toString());\n    }\n    expressionStr = strList.join('');\n    let value = result;\n    if (typeof value === 'number' && !isNaN(value)) {\n      value = roundNumber(value);\n    }\n    return {\n      result: value,\n      isError: false,\n      expressionStr,\n    };\n  } catch (error) {\n    if (error instanceof CustomError) {\n      return {\n        result: error.value,\n        isError: true,\n        expressionStr,\n      };\n    }\n  }\n  return {\n    result: '#ERROR!',\n    isError: true,\n    expressionStr,\n  };\n}\n\nexport class CellDataMapImpl implements CellDataMap {\n  private readonly map = new Map<string, ResultType>();\n  private sheetNameMap: Record<string, string> = {};\n  private cell: Coordinate = {\n    row: 0,\n    col: 0,\n  };\n  private getKey(row: number, col: number, sheetId: string) {\n    const key = `${row}_${col}_${sheetId}`;\n    return key;\n  }\n  setCurrentCell(cell: Coordinate) {\n    this.cell = cell;\n  }\n  setSheetNameMap(sheetNameMap: Record<string, string>) {\n    this.sheetNameMap = sheetNameMap;\n  }\n  set(range: IRange, value: ResultType[][]): void {\n    const { row, col, sheetId } = range;\n    for (let i = 0; i < value.length; i++) {\n      for (let j = 0; j < value[i].length; j++) {\n        const key = this.getKey(row + i, col + j, sheetId);\n        this.map.set(key, value[i][j]);\n      }\n    }\n  }\n  get(range: IRange): ResultType[] {\n    const list: ResultType[] = [];\n    const { row, col, rowCount, colCount, sheetId } = range;\n    for (let r = row, endRow = row + rowCount; r < endRow; r++) {\n      for (let c = col, endCol = col + colCount; c < endCol; c++) {\n        const key = this.getKey(r, c, sheetId);\n        const value = this.map.get(key);\n        if (typeof value !== 'undefined') {\n          list.push(value);\n        }\n      }\n    }\n\n    return list;\n  }\n  convertSheetNameToSheetId(sheetName: string): string {\n    return this.sheetNameMap[sheetName] || '';\n  }\n  getCurrentCell() {\n    return { ...this.cell };\n  }\n}\n\nexport class DefinedNamesMapImpl implements DefinedNamesMap {\n  private readonly map = new Map<string, IRange>();\n  set(name: string, value: IRange): void {\n    this.map.set(name, value);\n  }\n  get(name: string): IRange | undefined {\n    return this.map.get(name)!;\n  }\n}\n", "import {\n  RequestMessageType,\n  IRange,\n  ResultType,\n  ResponseMessageType,\n  InterpreterResult,\n  Coordinate,\n} from './types';\nimport { parseFormula, CustomError } from './formula';\nimport { iterateRange } from '@/util/range';\nimport { coordinateToString, stringToCoordinate } from '@/util/util';\n\nself.addEventListener('message', (event: MessageEvent<RequestMessageType>) => {\n  const list = parseAllFormulas(event.data);\n  const data: ResponseMessageType = {\n    list,\n  };\n  self.postMessage(data);\n});\n\nfunction parseAllFormulas(eventData: RequestMessageType) {\n  const { currentSheetId, worksheets } = eventData;\n  const formulaCache = new Map<string, InterpreterResult>();\n  const sheetData = worksheets[currentSheetId] || {};\n  const list: ResponseMessageType['list'] = [];\n  for (const [k, data] of Object.entries(sheetData)) {\n    if (data?.formula) {\n      const result = parseFormulaItem(\n        data.formula,\n        eventData,\n        formulaCache,\n        stringToCoordinate(k),\n        list,\n      );\n      if (result.result !== data.value) {\n        list.push({\n          key: k,\n          newValue: result.result,\n          sheetId: currentSheetId,\n        });\n      }\n    }\n  }\n  return list;\n}\n\nfunction parseFormulaItem(\n  formula: string,\n  eventData: RequestMessageType,\n  cache: Map<string, InterpreterResult>,\n  coord: Coordinate,\n  list: ResponseMessageType['list'],\n): InterpreterResult {\n  const temp = cache.get(formula);\n  if (temp) {\n    return temp;\n  }\n  const { currentSheetId, worksheets, definedNames, workbook } = eventData;\n  const result = parseFormula(\n    formula,\n    {\n      getCurrentCell: () => {\n        return coord;\n      },\n      get: (range: IRange) => {\n        const { row, col, sheetId } = range;\n        const realSheetId = sheetId || currentSheetId;\n        const result: ResultType[] = [];\n        const sheetInfo = workbook.find((v) => v.sheetId === realSheetId);\n        if (\n          !sheetInfo ||\n          row >= sheetInfo.rowCount ||\n          col >= sheetInfo.colCount\n        ) {\n          throw new CustomError('#REF!');\n        }\n        const sheetData = worksheets[realSheetId] || {};\n        iterateRange(range, sheetInfo, (r, c) => {\n          const key = coordinateToString(r, c);\n          if (sheetData[key]) {\n            const f = sheetData[key].formula;\n            const oldValue = sheetData[key].value;\n            if (f) {\n              const t = parseFormulaItem(f, eventData, cache, { row: r, col: c }, list);\n              if (t.result !== oldValue) {\n                list.push({ key, newValue: t.result, sheetId: realSheetId });\n              }\n              result.push(t?.result);\n            } else {\n              result.push(oldValue);\n            }\n          }\n          return false;\n        });\n        return result;\n      },\n      set: () => {\n        throw new CustomError('#REF!');\n      },\n      convertSheetNameToSheetId: (sheetName: string) => {\n        return workbook.find((v) => v.name === sheetName)?.sheetId || '';\n      },\n    },\n    {\n      set: () => {\n        throw new CustomError('#REF!');\n      },\n      get: (name: string) => {\n        return definedNames[name];\n      },\n    },\n  );\n  cache.set(formula, result);\n  return result;\n}\n"],
  "mappings": "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",
  "names": ["CELL_WIDTH", "COL_TITLE_WIDTH", "CELL_WIDTH", "XLSX_MAX_COL_COUNT", "XLSX_MAX_ROW_COUNT", "FORMULA_PREFIX", "SPLITTER", "MAX_PARAMS_COUNT", "FORMULA_MAX_PRECISION", "ERROR_SET", "DEFAULT_LINE_WIDTH", "BORDER_TYPE_MAP", "parseNumber", "value", "temp", "coordinateToString", "row", "col", "SPLITTER", "stringToCoordinate", "key", "r", "c", "CustomError", "value", "assert", "condition", "message", "mustOne", "list", "mustOneString", "mustOneNumber", "check", "num", "parseNumber", "mustEmpty", "isRelativeReference", "realValue", "T", "list", "value", "mustOne", "LOWER", "mustOneString", "CHAR", "mustOneNumber", "CODE", "LEN", "SPLIT", "assert", "sep", "UPPER", "TRIM", "CONCAT", "MAX_PARAMS_COUNT", "formulas", "text_default", "parseNumberArray", "list", "result", "i", "check", "num", "parseNumber", "ABS", "data", "mustOneNumber", "ACOS", "ACOSH", "ACOT", "ACOTH", "ASIN", "ASINH", "ATAN", "ATAN2", "assert", "x", "y", "ATANH", "AVERAGE", "rest", "MAX_PARAMS_COUNT", "sum", "cur", "COS", "COT", "EXP", "list", "data", "mustOneNumber", "INT", "PI", "list", "mustEmpty", "E", "SIN", "data", "mustOneNumber", "SUM", "rest", "parseNumberArray", "assert", "MAX_PARAMS_COUNT", "sum", "cur", "formulas", "ABS", "ACOS", "ACOSH", "ACOT", "ACOTH", "ASIN", "ASINH", "ATAN", "ATAN2", "ATANH", "AVERAGE", "COT", "COS", "EXP", "INT", "math_default", "roundNumber", "a", "temp", "result", "f", "FORMULA_MAX_PRECISION", "list", "t", "allFormulas", "text_default", "math_default", "formula_default", "Token", "type", "value", "columnNameToInt", "columnName", "temp", "num", "i", "rowLabelToInt", "label", "result", "isSheet", "range", "isRow", "isCol", "SheetRange", "_SheetRange", "row", "col", "rowCount", "colCount", "sheetId", "range", "iterateRange", "sheetInfo", "fn", "isSheet", "r", "isRow", "i", "isCol", "endRow", "endCol", "isAlpha", "char", "isDigit", "convertSheetNameToSheetId", "value", "parseCell", "ref", "convertSheetName", "realRef", "sheetName", "other", "i", "rowText", "colText", "rowCount", "colCount", "row", "col", "rowLabelToInt", "columnNameToInt", "XLSX_MAX_COL_COUNT", "XLSX_MAX_ROW_COUNT", "SheetRange", "parseReference", "text", "cell1", "cell2", "startCell", "endCell", "mergeRange", "start", "end", "parseNumber", "text", "num", "result", "t", "parseR1C1", "name", "activeCell", "list", "rowText", "colText", "row", "col", "XLSX_MAX_COL_COUNT", "XLSX_MAX_ROW_COUNT", "SheetRange", "emptyData", "identifierMap", "Scanner", "source", "Token", "text", "type", "end", "CustomError", "isDigit", "isAlpha", "isFloat", "float", "temp", "c", "FORMULA_PREFIX", "BinaryExpression", "left", "operator", "right", "visitor", "value", "result", "LiteralExpression", "UnaryExpression", "PostUnaryExpression", "R1C1Expression", "CellExpression", "type", "sheetName", "t", "name", "CallExpression", "params", "item", "CellRangeExpression", "GroupExpression", "TokenExpression", "Parser", "tokens", "result", "expr", "operator", "right", "BinaryExpression", "UnaryExpression", "PostUnaryExpression", "realRight", "realLeft", "CellRangeExpression", "CellExpression", "TokenExpression", "isRelativeReference", "LiteralExpression", "CustomError", "cell", "name", "params", "CallExpression", "value", "GroupExpression", "token", "realValue", "ERROR_SET", "R1C1Expression", "types", "type", "Token", "Interpreter", "expressions", "cellDataMap", "definedNamesMap", "functionMap", "result", "item", "CustomError", "data", "left", "right", "assert", "expr", "callee", "params", "t", "SheetRange", "list", "range", "parseR1C1", "sheetId", "parseReference", "type", "value", "check", "num", "parseNumber", "defineName", "temp", "funcName", "func", "isRelativeReference", "CellExpression", "a", "b", "mergeRange", "parseFormula", "source", "cellData", "CellDataMapImpl", "definedNamesMap", "DefinedNamesMapImpl", "functionMap", "formula_default", "expressionStr", "list", "Scanner", "expressions", "Parser", "result", "Interpreter", "strList", "item", "value", "roundNumber", "error", "CustomError", "row", "col", "sheetId", "cell", "sheetNameMap", "range", "i", "j", "key", "rowCount", "colCount", "r", "endRow", "endCol", "sheetName", "name", "event", "data", "parseAllFormulas", "eventData", "currentSheetId", "worksheets", "formulaCache", "sheetData", "list", "k", "result", "parseFormulaItem", "stringToCoordinate", "formula", "cache", "coord", "temp", "definedNames", "workbook", "parseFormula", "range", "row", "col", "sheetId", "realSheetId", "sheetInfo", "v", "CustomError", "iterateRange", "r", "c", "key", "coordinateToString", "f", "oldValue", "t", "sheetName", "name"]
}
